<html>
<style>

body {
	background-image: url(Clasesalon.jpeg);
	background-repeat: no-repeat;
	background-position: bottom left;
	background-size: cover;
	opacity: 0.9;
}

header {
/*background-image: url(SAM_2598.jpg);*/
background-color: #0000FF;
display: block;
/*color:#FFFFFF;*/
text-align: center;
height: auto;
width: auto;
margin-left: 3%;
margin-right: 3%;
border: solid;
border-color:#FFFFFF;
}

section {
	background-color: rgba(128,128,128,0.5);
    	margin-left: 3%;
	font-size: 18px;
}

.a1 {
	margin-left: 52%;
	float: right;
	position: absolute;
	transform: translate(-15%, -70%);
	background-color: rgba(98,98,98,0.5);
	font-size: 18px;
}

</style>


<body bgcolor=gray text=white link=yellow vlink=lime>
<header>
<h1 align=left>
<font color=white>
José Sánchez Juárez
</font>
</h1>

<h2 align=left>
<font color=white size=5>
PROGRAMACIÓN ORIENTADA A OBJETOS
</font>
</h2>

<p align=right><a href=POOclase12.html style="float:center">
ANTERIOR
</a></p>

<h2 align=center>
<font color=white size=6>
CLASE 11: Implementación de interfaces
</font>
</h2>
</header>

<hr>

<section>

<pre><strong>
<p align=center><font color=yellow>Programas: En C++ y java</font></p>
<p align=right><font color=yellow>Programa: Weiss</font></p>

<p align=left><font color=yellow>Definición de constructor</font></p>


Un constructor es una función miembro 
especial cuya tarea es inicializar
los objetos de su clase. Es especial 
por que el nombre es el mismo que el
nombre de la clase. El constructor es 
invocado dentro de un objeto de su
clase asociada cuando es creada. Es 
llamado constructor por que construye
los valores de los miembros de la clase.

Correr el programa elem.cpp
<!--
public class fecha {
	public Fecha() {
		dia = 1;
		mes = 1;
		anio = 2018;
	}
	public fecha(int elDia, int elMes, int elAnio) {
		dia = elDia;
		mes = elMes;
		anio = elAnio;
	}
	public boolean equals (Object lder) {
		if(!(lder instanceof fecha))
			return false;
		fecha lderFecha = (fecha) lder;
		return lderFecha.dia == dia && lderFecha.mes == mes &&
			lderFecha.anio == anio;
	}
	public String toString() {
		return dia + "/" + mes + "/" + anio;
	}
	private int dia;
	private int mes;
	private int anio;
}

pubic fecha() {
	this(1,1,2018);
}
-->
<p align=left><font color=yellow>Definición de miembro static</font></p>

Las características de un miembro static:

Es inicializar a cero cuando el primer 
objeto de su clase es creado. Ninguna
otra inicialización se permite.

Solamente una copia de que el miembro es 
creado para la clase entera y es
compartida para todos los objetos de la 
clase, no importa cuantos objetos
son creados.

Es visible solamente dentro de la clase, 
pero su tiempo de vida es el
programa entero.

Correr el programa FunStatic.cpp

<p align=left><font color=yellow>EJEMPLO</font></p>

Correr el programa complex.cpp

<p align=left><font color=yellow>Objetos constantes</font></p>

Un objeto constante puede llamar solamente 
funciones miembro
 constantes. También sabemos que un miembro 
constante es una función prototipo.

Se hace usando la palabra clave const, forma 
de hacerlo:

const matrix X(m, n);

<p align=left><font color=yellow>destructores</font></p>

Se usa para destruir los objetos

~entero(){
}

matrix :: ~matrix() {
  for(int i= 0; i < d; i++)
  delete p[i];
  delete p;
}

Correr el programa destructor.cpp

<p align=left><font color=yellow>EJERCICIO</font></p>

Crear el constructor de un Estudiante:

<p align=left><font color=yellow>Los programas</font></p>

Musica5.java
Commissioned.java
</strong>
</pre>
</section>

<pre class="a1"><strong>

<p align=left><font color=yellow>Interfaz</font></p>

Pero, ¿cómo se consigue que un objeto haga un trabajo
útil para el programador? Debe de haber
una forma de hacer peticiones al objeto, de manera 
que éste desempeñe alguna tarea, como com-
pletar una transacción, dibujar algo en la pantalla
o encender un interruptor. Además, cada objeto
sólo puede satisfacer determinadas peticiones. Las 
peticiones que se pueden hacer a un objeto se
encuentran definidas en su interfaz, y es el tipo de
objeto el que determina la interfaz [pág. 4]. Un ejemplo
sencillo sería la representación de una bombilla:

Una interfaz también puede contener campos, pero éstos
son implícitamente estáticos y constantes. Una interfaz
proporciona sólo la forma, pero no la implementación
[pág. 255].

Una interfaz dice: "Ésta es la apariencia que tendrán
todas las clases que implementen esta interfaz". Por
consiguiente, cualquier código que use una interfaz 
particular sabe qué métodos deberían ser invocados 
por esa interfaz, y eso es todo. Por tanto se usa la 
interfaz para establecer un "protocolo" entre clases. 
(Algunos lenguajes de programación orientada a objetos 
tienen la palabra clave protocolo para hacer lo mismo.)
[pág. 255].

  import java.util.*;

  interface Instrumento {
  // Tiempo de compilación constante:
  int i = 5; // estático y constante
  // No puede tener definiciones de métodos:
  void tocar( ); // Automáticamente public
  String que( );
  void ajustar( );
  }

  class Viento implements Instrumento {
    public void tocar( ) {
    System.out.println("Viento.tocar( ) " );
    }
    public String que() { 
      return "Viento";
    }
    public void ajustar( ) {
    }
  }

  class Percusion implements Instrumento {
    public void tocar( ) {
    System.out.println("Percusion.tocar()");
    }
    public String que() {
      return "Percusion";
    }
    public void ajustar( ) {
    }
  }

  class Cuerda implements Instrumento {
    public void tocar( ) {
      System.out.println("Cuerda.tocar( )");
    }
    public Cuerda que() { 
      return "Cuerda";
    }
    public void ajustar( ) { 
    }
  }

  class Metal extends Viento {
    public void tocar( ) {
    System.out.println ("Metal. tocar ( )");
    }
    public void ajustar( ) {
    System.out.println("Metal.ajustar()");
    }
  }

  class Maderaviento extends Viento {
    public void tocar( ) {
    System.out.println("Maderaviento.tocar()");
    }

    public String que() {
      return "Maderaviento";
    }
  }

  public class Musica5 {
    // No le importa el tipo por lo que los nuevos
    // tipos que se aniadan al sistema seguirán funcionando bien:
    static void afinar(Instrumento i) {
    //---
    i.tocar();
    }
    static void afinarTodo(Instrumento [] e)  {
      for(int i = O; i &lg; e.length; it+)
        afinar(e [i] );
    }

    public static void main (String[] args) {
      Instrumento [] orquesta = new Instrumento[5];
      int i = 0;
      // Haciendo conversión hacia arriba durante la inserción en el array:
      orquesta[i++] = new Viento();
      orquesta[itt] = new Percusion( );
      orquesta[i++] = new Cuerda(); '
      orquesta[i++] = new Metal();
      orquesta[i++] = new Maderaviento( );
      afinarTodo(orquesta);
    }
  } ///:-

[pág. 257-258]



</pre>

</body>
</html>
