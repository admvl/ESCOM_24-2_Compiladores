<html>
<style>
header {
background-color: #8ba987;
display: block;
color:#FFFFFF;
text-align: center;
height: auto;
width: auto;
margin-left:21%;
border: solid;
border-color:#FFFF00;
}

h2 {  font-size: 30px;
      margin: 0px;
}

article {
background-color: #8ba987;
display: block;
margin-left: 21%;
margin-top: 0.5%;
padding: 1px;
-webkit-border-radius: 10px;
-moz-border-radius: 10px;
border-radius: 10px;
-webkit-box-shadow: 2px 2px 20px #888;
-webkit-transform: rotate(-0deg);
-moz-box-shadow: 2px 2px 20px #888;
-moz-transform: rotate(-0deg);
width: auto;	
height: auto;	
}

article header {
background-color: #009F80;
-webkit-border-radius: 10px;
-moz-border-radius: 10px;
border-radius: 10px;
border-color:#800000;
padding: 2px;
height: auto;
width: 40%;
text-align: center;
font-size: 20px;
margin-left: auto;
margin-right: auto;
margin-bottom: 5%;
margin-top: 5%;
}

article h1 {
font-size: 20px;

}

article div{
background-color: #8ba987;
-webkit-border-radius: 10px;
-moz-border-radius: 10px;
border-radius: 10px;
border-color:#0000FF;
padding: 5px;
width:40%;
text-align: center;
margin-left:0%;
}

p.par1  {
 background-color: #808080;
 font-size: 28px;
 width: 200px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #00f;
 font: normal 15px arial, helvetica, sans-serif;
 }

p.p2  {
 background-color: #808080;
 font-size: 28px;
 width: 500px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #00f;
 font: normal 15px arial, helvetica, sans-serif;
 }

p.p3  {
 background-color: #808080;
 font-size: 28px;
 width: 500px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #f60;
 font: normal 15px arial, helvetica, sans-serif;
 }

p.p4  {
 background-color: #808080;
 font-size: 20px;
 width: 230px;
 margin: 10px 20px;
 padding: 10px;
 border: solid 6px #f60;
 font: normal 15px arial, helvetica, sans-serif;
 }

pre.p2  {
 background-color: #808080;
 font-size: 28px;
 width: 500px;
 margin: 10px auto;
 padding: 5px;
 border: solid 6px #80A93E;
 font: normal 15px arial, helvetica, sans-serif;
 }

	.modalDialog {
		position: fixed;
		font-family: Arial, Helvetica, sans-serif;
		top: 0;
		right: 0;
		bottom: 0;
		left: 0;
		background: rgba(0,0,0,0.2);
		z-index: 99999;
		opacity:0;
		-webkit-transition: opacity 400ms ease-in;
		-moz-transition: opacity 400ms ease-in;
		transition: opacity 400ms ease-in;
		pointer-events: none;
	}
	.modalDialog:target {
		opacity:1;
		pointer-events: auto;
	}
	.modalDialog > div {
		width: 30%;
		position: relative;
		margin: 10% auto;
		padding: 5px 20px 13px 20px;
		border-radius: 10px;
		background: #fff;
		background: -moz-linear-gradient(#fff, #999);
		background: -webkit-linear-gradient(#fff, #999);
		background: -o-linear-gradient(#fff, #999);
	  	-webkit-transition: opacity 400ms ease-in;
		-moz-transition: opacity 400ms ease-in;
		transition: opacity 400ms ease-in;
	}
	.close {
		background: #606061;
		color: #FFFFFF;
		line-height: 25px;
		position: absolute;
		right: -12px;
		text-align: center;
		top: -10px;
		width: 24px;
		text-decoration: none;
		font-weight: bold;
		-webkit-border-radius: 12px;
		-moz-border-radius: 12px;
		border-radius: 12px;
		-moz-box-shadow: 1px 1px 3px #000;
		-webkit-box-shadow: 1px 1px 3px #000;
		box-shadow: 1px 1px 3px #000;
	}
	.close:hover { background: #00d9ff; }

table {
  margin-left: 25%;
  padding: 10px;
}

.t {
  margin-left: -5%;
  margin-top: -10%;
  padding: 10px;
}

.lateral {
	position: fixed; /* Hacemos que la posiciÃ³n en pantalla sea fija para que siempre se muestre en pantalla*/
	left: 0; /* Establecemos la barra en la izquierda */
	top: 500px; /* Bajamos la barra 200px de arriba a abajo */
	z-index: 2000; /* Utilizamos la propiedad z-index para que no se superponga algÃºn otro elemento como sliders, galerÃ­as, etc */
}

</style>

<head>
<title>AnÃ¡lisis SintÃ¡ctico</title>
</head>

<body bgcolor=gray text=white link=yellow vlink=lime>
<!--
<a>
<img src="LibCompiladores.svg" align=left alt="seleccione aquÃ­ para visitar la pÃ¡gina oficial de Instraw" width=20% border=0>
</a>-->


<a>
<img src=CapAnalisisSintactico.svg align=left alt="seleccione aquÃ­ para visitar la pÃ¡gina oficial del material" width=20% height=45% border=0>
</a>

<header>
<img src=Estudiante.svg align=left alt="seleccione aquÃ­ para visitar la pÃ¡gina oficial del material" width=9% height=15% border=0>

<!--
<img src=CapAnalisisSintactico.svg align=right alt="seleccione aquÃ­ para visitar la pÃ¡gina oficial del material" width=16% height=97% border=0>-->

<h1 align=left>
<font color=maroon size=8>
CAPÃTULO 3
</font>
</h1>

<h2 align=left>
<font color=white size=6>
AnÃ¡lisis SintÃ¡ctico
</font>
</h2>
</header>

<hr>


<nav>
<h3 align=center><font size=6>Ãndice</font></h3>

<p align=center><font size=5>
El material de estudio para el estudiante que se presenta en esta pÃ¡gina, esta dividido de acuerdo al temario de la asignatura.</font></p>

<h3 align=center><font size=6>Temas:</font></h3>

<a href=#arq>
Analizadores SintÃ¡cticos.
</a>
&nbsp; &nbsp;
<a href=#def>
Tipos de analizadores sintÃ¡cticos.
</a>
&nbsp; &nbsp;
<a href=http://www.civila.com/instraw/ejemplo/recursos.html>
Analizadores sintÃ¡cticos descendentes.
</a>
&nbsp; &nbsp;
<a href=Material1.html>
Analizadores sintÃ¡cticos ascendentes.
</a>
&nbsp; &nbsp;
<a href=#def>Ejercicios.</a>
&nbsp; &nbsp;
<a href=#def>Generadores de analizadores sintÃ¡cticos</a>

</nav>


<hr>


<article>
<div class="section-content" style="width: auto;">
<p style="text-align: center; ">El anÃ¡lisis sintÃ¡ctico es menos local que el anÃ¡lisis lÃ©xico, donde se requieren
mÃ©todos mÃ¡s avanzados. Se usa la misma estrategia: una notaciÃ³n mÃ¡s fÃ¡cil
para el entendimiento humano es transformada en una mÃ¡quina, semejante a
una mÃ¡s sencilla de bajo nivel para una ejecuciÃ³n mÃ¡s eficiente. Este proceso es
llamado generaciÃ³n del analizador.</p>

<header>
<h3 align="center" id=#arq>Analizadores SintÃ¡cticos</h3>
</header>

<p>En la etapa de anÃ¡lisis sintÃ¡ctico de un compilador se verifican los tokens
reconocidos por el analizador lÃ©xico, los cuales son agrupados de acuerdo a reglas
sintÃ¡cticas del lenguaje. Si los tokens en una cadena son agrupados de acuerdo a
reglas de sintaxis del lenguaje, entonces las cadenas de tokens entregados por el
analizador lÃ©xico, son aceptadas como construcciÃ³n vÃ¡lida del lenguaje; de otra
manera un manejo de errores se aplica. Se deben tomar en cuenta dos casos al
diseÃ±ar la fase de anÃ¡lisis sintÃ¡ctico en un proceso de compilaciÃ³n;
Primero todas las construcciones vÃ¡lidas de un lenguaje de programaciÃ³n
deben ser especificadas: y para usar estas especificaciones un programa vÃ¡lido se
forma. Aquellas, que nosotros formamos en una especificaciÃ³n de aquellos tokens
que el analizador lÃ©xico regresarÃ¡, y que nosotros especificamos de que manera
estos tokens son agrupados, de modo que lo que resulte del agrupamiento sea
una construcciÃ³n vÃ¡lida del lenguaje.
Segundo debe ser usada una notaciÃ³n apropiada para especificar la cons-
trucciÃ³n de un lenguaje. La notaciÃ³n para especificar la construcciÃ³n debe
ser compacta, precisa y fÃ¡cil de entender. La especificaciÃ³n de la estructura
sintÃ¡ctica para el lenguaje de programaciÃ³n (es decir, la construcciÃ³n vÃ¡lida
del lenguaje) usa gramÃ¡ticas libres de contexto (GLC), porque para ciertas clases de gramÃ¡ticas, nosotros podemos automÃ¡ticamente construir un analizador
sintÃ¡ctico que determine si un programa fuente es sintÃ¡cticamente correcto.
Para encontrar la estructura del texto de entrada, el anÃ¡lisis sintÃ¡ctico debe
rechazar el texto invalido para reportar los errores de sintaxis. A partir de un
reconocedor (analizador lÃ©xico) adecuado que serÃ¡ diseÃ±ado para reconocer si
una cadena de tokens es una construcciÃ³n vÃ¡lida o no.</p>

<font color=yellow><h4 align="center">FormalizaciÃ³n de gramÃ¡ticas</h4></font>

<p>Formalizar quiere decir ser preciso o determinado en la forma de representar
las gramÃ¡ticas, por lo que para cumplir con esto una gramÃ¡tica se expresa por
medio de un cuarteto, como se muestra en la definiciÃ³n siguiente:</p>

DefiniciÃ³n 1.

<p>De esta manera la gramÃ¡tica queda expresada de manera formal, ya que
la precisiÃ³n radica en la forma de las producciones, basadas en la jerarquÄ±Ìa de
Chomsky.
Para ejemplificar el uso de la representaciÃ³n formal. Se presenta el siguiente
ejemplo:</p>

EJEMPLO 1.

<font color=red><h4 align="center">[N<SUB>i</SUB> â†’ h<SUB>X</SUB> 1 i x 1 Â· Â· Â· hX n i x n</h4></font>

<p>donde hN i representa el conjunto de los no terminales y que se llama la par-
te izquierda de la producciÃ³n, y hX 1 i x 1 Â· Â· Â· hX n i x n es la parte derecha de
la producciÃ³n y representan cero o mÃ¡s sÄ±Ìmbolos, cada uno de los sÄ±Ìmbolos x 1
Â· Â· Â· x n son terminales y cada uno de los sÄ±Ìmbolos hX 1 i Â· Â· Â· hX n i son no terminales.
Pero la representaciÃ³n de las producciones para mayor facilidad, se hace sin
usar los parÃ©ntesis triangulares y se usa el sÄ±Ìmbolo â†’ en lugar del sÄ±Ìmbolo ::=.
Las gramÃ¡ticas libres de contexto sirven para representar reglas sintÃ¡cticas
pero tambiÃ©n pueden expresar algunos sonidos de mÃ¡quinas, como se muestra
en el ejemplo siguiente:</p>

EJEMPLO 2.

<font color=yellow><h4 align="center">JerarquÄ±Ìa de Chomsky</h4></font>

<p>Las gramÃ¡ticas se clasifican segÃºn la forma de la producciÃ³n en la jerarquÄ±Ìa
de Chomsky, donde se establecen cuatro clases de gramÃ¡ticas, las cuales se
enumeran del 0 al 3 [6]:</p>

DEFINICION 2.

<font color=yellow><h4 align="center">Ejemplo de gramÃ¡ticas formales</h4></font>

<p>Un ejemplo de gramÃ¡tica es la siguiente G 1 = ({S}, {a, b}, P 1 , S) :</p>

EJEMPLO 3.

<p>Ya que cada producciÃ³n de la gramÃ¡tica G 1 tiene la forma de la gramÃ¡tica 2 de Chomsky, como 
se muestra en el cuadro 2 , esta es una gramÃ¡tica libre de contexto:</p>

Cuadro 1.

<font color=yellow><h4 align="center">Derivaciones</h4></font>

<p>Sean Î´ 1 y Î´ 2 dos cadenas de caracteres, si la cadena Î´ 1 se transforma en la
cadena Î´ 2 utilizando el conjunto de producciones de la gramÃ¡tica, es a lo que se
llaman derivaciÃ³n y se representan de la siguiente forma:</p>

<font color=red><h4 align="center">Î´ 1 â‡’ Î´ 2</h4></font>

<p>ObtenciÃ³n de derivaciones Para hacer las derivaciones se utilizan las defi-
niciones de forma sentencial y desde luego la definiciÃ³n de derivaciÃ³n.</p>

DefiniciÃ³n 3.

<p>En cada paso de las derivaciones se obtienen las formas sentenciales:</p>

DefiniciÃ³n 4.

<p>En cada paso se aplican las producciones de la gramÃ¡tica para producir la
forma sentencial.</p>

<p>Tipos de derivaciones Existen dos formas de derivar las cadenas de carac-
teres, la derivaciÃ³n por la derecha y la derivaciÃ³n por la izquierda.</p>

DefiniciÃ³n 5.

DefiniciÃ³n 6.

<font color=yellow><h4 align="center">Ejemplo de derivaciones</h4></font>

<p>Para poder acoplar las producciones de la gramÃ¡tica G 1 con las cadenas de
caracteres que se presentan en el cÃ³digo fuente, se aplican las derivaciones de la
siguiente forma: si se tiene la cadena abba, la que se deriva en:</p>

<font color=red><h4 align="center">S â‡’ aSa â‡’ abSba â‡’ ab&epsilon;ba â‡’ abba</h4></font>

<p>Lo que se puede expresar como:</p>

<font color=red><h4 align="center">S â‡’ âˆ— abba</h4></font>

<p>Otro ejemplo de derivaciones Se tiene la gramÃ¡tica G 2 = (N 2 , T 2 , P 2 , S 2 )
con el conjunto de producciones P 2 :</p>

P 2 = {E â†’ E + E,
E â†’ E âˆ— E,
E â†’ (E),
E â†’ id}

<p>Desarrollar por medio de derivaciones izquierdas y derivaciones derechas la
siguiente cadena, id + id * id.</p>

mÃ©todo 1.

<font color=yellow><h4 align="center">DerivaciÃ³n derecha:</h4></font>

<font color=red><h4 align="center">E â‡’ D E âˆ— E â‡’ D E âˆ— id â‡’ D E + E âˆ— id â‡’ D E + id âˆ— id â‡’ D id + id âˆ— id</h4></font>

<font color=yellow><h4 align="center">DerivaciÃ³n izquierda:</h4></font>

<font color=red><h4 align="center">E â‡’ I E âˆ— E â‡’ I E + E âˆ— E â‡’ I id + E âˆ— E â‡’ I id + id âˆ— E â‡’ I id + id âˆ— id</h4></font>

<font color=yellow><h4 align="center">Ãrboles de anÃ¡lisis sintÃ¡ctico</h4></font>

<p>Los tipos de Ã¡rboles que hay, son: los Ã¡rboles de anÃ¡lisis sintÃ¡cticos y los
Ã¡rboles de derivaciÃ³n.</p>

DefiniciÃ³n 7.

<p>Si tenemos la siguiente gramÃ¡tica, el Ã¡rbol de anÃ¡lisis sintÃ¡ctico es el que se
muestra en la figura :</p>

EJEMPLO 4.

<p>El Ã¡rbol de derivaciones se define:</p>

DefiniciÃ³n 8.

<p>Si tenemos a la gramÃ¡tica G 3 = (N, T, P 3 , S) con el siguiente conjunto de
producciones P 3 :</p>

<font color=red><h4 align="center">P 3 = {E â†’ E + E, E â†’ E âˆ— E,
E â†’ id}</h4></font>

EJEMPLO 5.

<p>Otro ejemplo de Ã¡rbol de derivaciones para la cadena de caracteres abba ob-
tenida por derivaciones, que se desarrolla aplicando el conjunto de producciones
P 1 de la gramÃ¡tica G 1 , como se muestra a continuaciÃ³n:</p>

<font color=red><h4 align="center">S â‡’ aSa â‡’ abSba â‡’ ab&epsilon;ba â‡’ abba</h4></font>

EJEMPLO 6.

<p>El libro [5] cita que el Ã¡rbol sintÃ¡ctico es el mismo que el Ã¡rbol de derivaciÃ³n.
AsÄ±Ì que consideraremos en estos apuntes que el Ã¡rbol de derivaciÃ³n y el Ã¡rbol
sintÃ¡ctico son lo mismo.</p>

<font color=yellow><h4 align="center">Diferencia entre gramÃ¡ticas regulares y gramÃ¡ticas libres de contexto</h4></font>

<p>El listado de palabras con una cantidad de aâ€™s emparejadas, es el siguiente
{aba, aabaa, aaabaaa, Â· Â· Â· }, que se representa por el conjunto de producciones:</p>

1.S â†’ aCa
2.C â†’ aCa
3.C â†’ b

<p>que son parte del cuarteto de la gramÃ¡tica formal del tipo libre de contexto.
Aplicando la gramÃ¡tica anterior y las derivaciones se obtiene la cadena
aaabaaa:</p>

<font color=red><h4 align="center">S â‡’ D aCa â‡’ D aaCaa â‡’ D aaaCaaa â‡’ D aaabaaa</h4></font>

<p>Sin embargo esta cadena tambiÃ©n se puede obtener por medio de la gramÃ¡tica
formal que se enlista a continuaciÃ³n:</p>

1.S â†’ aS
2.S â†’ aB
3.B â†’ bC
4.C â†’ aC
5.C â†’ a

<p>De la derivaciÃ³n se obtiene aplicando la gramÃ¡tica anterior, la cadena aaa-
baaa:</p>

<font color=red><h4 align="center">S â‡’ D aS â‡’ D aaS â‡’ D aaaB â‡’ D aaabC â‡’ D aaabaC
â‡’ D aaabaaC â‡’ D aaabaaa</h4></font>

<p>La diferencia esta en que con la gramÃ¡tica libre de contexto no se puede
obtener la cadena aabaaaa y con la gramÃ¡tica regular si se puede obtener:</p>

<font color=red><h4 align="center">S â‡’ D aS â‡’ D aaB â‡’ D aabC â‡’ D aabaC â‡’ D aabaaCâ‡’ D aabaaaC â‡’ D aabaaaa</h4></font>

<p>Esto quiere decir que no se puede obtener una cadena emparejada, por ejem-
plo los parÃ©ntesis emparejados que son esenciales en anÃ¡lisis sintÃ¡ctico.</p>

EJEMPLO 7.

<font color=yellow><h4 align="center">RepresentaciÃ³n de gramÃ¡ticas libres de contexto</h4></font>

<p>Las gramÃ¡ticas libres de contexto se representan como ya se dijo por medio
de cuartetos, pero tambiÃ©n se representan por medio de la teorÄ±Ìa de conjuntos:</p>

<font color=red><h4 align="center">{cadena|logica}</h4></font>

<p>ya que se requiere representar las estructuras por medio de un listado de la
teorÄ±Ìa de conjuntos, con la finalidad de expresar caracterÄ±Ìsticas que no se pue-
den observar por medio de la representaciÃ³n formal de las gramÃ¡ticas libres de
contexto. Como se muestra con el siguiente ejemplo:
GramÃ¡tica libre de contexto
La gramÃ¡tica con conjunto de producciones:</p>

<font color=red><h4 align="center">P = {S â†’ aCa,
C â†’ aCa,
C â†’ b}</h4></font>

<p>Se representa por medio de la teorÄ±Ìa de conjuntos de la siguiente forma:</p>

<font color=red><h4 align="center">L(G) = {a n ba n |n â‰¥ 1}</h4></font>

<p>GramÃ¡tica regular La gramÃ¡tica con conjunto de producciones:</p>

<font color=red><h4 align="center">P = {S â†’ aS,
S â†’ aB,
B â†’ bC,
C â†’ aC,
C â†’ a}</h4></font>

<p>Se representa por medio de la teorÄ±Ìa de conjuntos de la siguiente forma:</p>

<font color=red><h4 align="center">L(G) = {a<SUP>n</SUP> ba<SUP>m</SUP> |n, m â‰¥ 1}</h4></font>

EJEMPLO 8.

<font color=yellow><h4 align="center">GramÃ¡ticas ambiguas</h4></font>

<p>Para la construcciÃ³n de analizadores sintÃ¡cticos se usan las gramÃ¡ticas libres
de contexto, las cuales no todas son ideales. Existe el problema de que pueden
ser ambiguas. Una gramÃ¡tica es ambigua si existe alguna cadena de terminales
que pueda obtenerse mediante Ã¡rboles de derivaciÃ³n distintos (dos Ã¡rboles dis-
tintos dan la misma cadena). El problema de la ambigÃ¼edad es que esta genera
retroceso en la programaciÃ³n.</p>

DefiniciÃ³n 9.

<p>Para la gramÃ¡tica G 3 , la cadena id + id âˆ— id se obtiene por dos Ã¡rboles de
derivaciÃ³n diferentes. El segundo Ã¡rbol de derivaciÃ³n se obtiene de la serie de
derivaciones E â‡’ E âˆ— E â‡’ E + E âˆ— E â‡’ id + E âˆ— E â‡’ id + id âˆ— E â‡’ id + id âˆ— id,
y el Ã¡rbol de anÃ¡lisis sintÃ¡ctico es el siguiente:</p>

Figura3.

<p>Como esta derivaciÃ³n tiene dos Ã¡rboles de anÃ¡lisis sintÃ¡cticos diferentes, el
Ã¡rbol de anÃ¡lisis sintÃ¡ctico de la figura 1 y el Ã¡rbol de anÃ¡lisis sintÃ¡ctico de la
figura 3, entonces la gramÃ¡tica G 3 es una gramÃ¡tica ambigua.</p>

<p>Otro ejemplo de gramÃ¡tica ambigua. Es la gramÃ¡tica G 4 con las siguien-
tes producciones:</p>

<font color=red><h4 align="center">S â†’ aSbS|bSaS|&epsilon;</h4></font>

<p>Para obtener la siguiente cadena de caracteres abab, se obtiene por medio de
las siguientes derivaciones:</p>

<font color=red><h4 align="center">S â‡’ aSbS â‡’ abSaSbS â‡’ ab&epsilon;aSbS â‡’ aba&epsilon;bS â‡’ abab&epsilon; â‡’ abab</h4></font>

<p>El Ã¡rbol de anÃ¡lisis sintÃ¡ctico es el siguiente:</p>

Figura 4.

<p>Para la gramÃ¡tica G 4 se puede obtener otro Ã¡rbol de anÃ¡lisis sintÃ¡ctico. Por
lo que esta gramÃ¡tica es ambigua.</p>

<font color=yellow><h4 align="center">EliminaciÃ³n de la ambigÃ¼edad</h4></font>

<p>Si para una cadena de caracteres terminales con las producciones de una
gramÃ¡tica no se obtienen dos Ã¡rboles de derivaciÃ³n diferentes, entonces se dice
que una gramÃ¡tica no es ambigua. Y se puede decir que una gramÃ¡tica ambigua
al aplicarle las transformaciones, se demuestra que no cumple con el concepto
de una gramÃ¡tica ambigua, entonces se afirma que se ha eliminado la
ambigÃ¼edad.</p>

<p>La eliminaciÃ³n de la ambigÃ¼edad en las gramÃ¡ticas libres de contexto se hace
de diferentes maneras:</p>

<p>Uno, reduciendo la gramÃ¡tica. Esto se refiere a identificar aquellos sÄ±Ìmbo-
los gramaticales (llamados sÄ±Ìmbolos gramaticales no usuales) y desde luego a las
producciones que no juegan un papel en la derivaciÃ³n, la cual podemos eliminar
de la gramÃ¡tica.</p>

<p>De una gramÃ¡tica un sÄ±Ìmbolo usual X es aquel que cumple lo siguiente:</p>

1. Si este deriva en una cadena de terminales.
2. Es usado en al menos en una derivaciÃ³n de w.
Por lo que:
1. X â‡’ âˆ— w, dÃ³nde w esta en T âˆ— .
2. S â‡’ âˆ— Î±XÎ² â‡’ âˆ— w en L(G).

EJEMPLO 9.

Ejercicio 1.

EJEMPLO 10.

<p>Dos, reescribiendo la gramÃ¡tica. tambiÃ©n reescribiendo la gramÃ¡tica:
Para eliminar la ambigÃ¼edad se hace Para reescribir la gramÃ¡tica de tal manera que se elimine la ambigÃ¼edad se hace de la siguiente manera:</p>

<font color=red><h4 align="center">E â†’ E + T |E âˆ’ T |T
T â†’ T âˆ— F |T /F |F
F â†’ (E)|id</h4></font>

<p>De la siguiente gramÃ¡tica obtener la cadena de caracteres aabbbcc:</p>

<font color=red><h4 align="center">T â†’ R,
T â†’ aT c,R â†’ &epsilon;,
R â†’ RbR</h4></font>

<p>Se hacen las siguientes derivaciones:</p>

<font color=red><h4 align="center">T â‡’ aT c â‡’ aaT cc â‡’ aaRcc â‡’ aaRbRcc â‡’ aaRbcc â‡’ aaRbRbcc â‡’
aaRbRbRbcc â‡’ aaRbbRbcc â‡’ aabbRbcc â‡’ aabbbcc</h4></font>

<p>Otra derivaciÃ³n es la siguiente:</p>

<font color=red><h4 align="center">T â‡’ aT c â‡’ aaT cc â‡’ aaRcc â‡’ aaRbRcc â‡’ aaRbRbRcc â‡’ aabRbRcc â‡’ aabRbRbRcc â‡’ aabbRbRcc â‡’ aabbbRcc â‡’ aabbbcc</h4></font>

<p>Ahora la gramÃ¡tica reescrita es la siguiente:</p>

<font color=red><h4 align="center">T â†’ R,
T â†’ aT c,
R â†’ &epsilon;,
R â†’ bR</h4></font>

<p>La siguiente gramÃ¡tica es ambigua:</p>

<font color=red><h4 align="center">E â†’ E Op E,
E â†’ num</h4></font>

<p>Ahora se reescribe la gramÃ¡tica de la siguiente manera:</p>

<font color=red><h4 align="center">E â†’ E Op E' ,
E â†’ E' ,
E' â†’ num</h4></font>

<p>Pero ahora se tiene el problema de la recursividad izquierda.</p>

<p>Tres, recursividad izquierda. En el reconocimiento de tokens de izquierda
a derecha se presenta un problema. Consideremos la siguiente gramÃ¡tica G<SUB>4</SUB>:</>

<font color=red><h4 align="center">E â†’ E + T |T,
T â†’ T âˆ— F |F,
F â†’ i|(E)</h4></font>

<p>Y analicemos la expresiÃ³n i + i + i. Se aplican las siguientes derivaciones:</p>

<font color=red><h4 align="center">E â‡’ E + T â‡’ E + T + T â‡’ T + T + T â‡’ F + T + T â‡’ i + T + T
â‡’ i + F + T â‡’ i + i + T â‡’ i + i + F â‡’ i + i + i</h4></font>

<p>Ã¡rbol de anÃ¡lisis sintÃ¡ctico es el siguiente:</p>

Figura 5.

<font color=red><h4 align="center">E â‡’ E + T â‡’ E + T + T â‡’ E + T + T + T â‡’ ...</h4></font>

<p>El problema que se presenta en las producciones es la recursividad izquierda.
Ya que la producciÃ³n E â†’ E + T tiene la siguiente forma:</p>

<font color=red><h4 align="center">A â†’ AÎ±</h4></font>

<p>O lo que es lo mismo A = E y Î± = +T , por lo que la gramÃ¡tica G 4 tiene
recursividad izquierda.
Un anÃ¡lisis descendente para la gramÃ¡tica G 4 comenzarÃ¡ por expandir E
con la producciÃ³n E â‡’ E + T . Se tratarÃ¡ de expandir de nuevo E de la misma
forma. Esto da el siguiente Ã¡rbol de anÃ¡lisis sintÃ¡ctico:</p>

Figura 6.

<p>pero no sabemos cuando se debe expandir con E â†’ T en lugar de otra vez
usar E â‡’ E + T . Esto se soluciona eliminando la recursividad izquierda.</p>

<font color=yellow><h4 align="center">EliminaciÃ³n de la recursiÃ³n izquierda en las gramÃ¡ticas</h4></font>

<p>Las producciones que tienen recursividad izquierda, se igualan carÃ¡cter a
carÃ¡cter con las siguientes producciones:</p>

<font color=red><h4 align="center">A â†’ AÎ±|Î²</h4></font>

<p>Aunque tambiÃ©n se pueden usar las siguientes producciones:</p>

<font color=red><h4 align="center">A â†’ BÎ±| . . .
B â†’ AÎ²| . . .</h4></font>

<p>Para despuÃ©s hacer la siguiente transformaciÃ³n:</p>

<font color=red><h4 align="center">A â†’ Î²A 0
A 0 â†’ Î±A 0 |&epsilon;</h4></font>

EJEMPLO 11.

EJEMPLO 12.

EJEMPLO 13.

EJEMPLO 14.

EJEMPLO 15.

<font color=yellow><h4 align="center">Ãrboles de sintaxis</h4></font>

<p>El Ã¡rbol de sintaxis abstracta (ASA) o Ã¡rbol de anÃ¡lisis sintÃ¡ctico es el
resultado de simplificar el Ã¡rbol sintÃ¡ctico concreto (ASC) hasta llegar a obtener
lo que se necesita para representar el significado del programa. El ASA es un
Ã¡rbol que se define con mayor simplicidad y por lo tanto es mÃ¡s fÃ¡cil de procesar
en las etapas de ejecuciÃ³n.
Para representar a los Ã¡rboles existe una notaciÃ³n que se escribe como a
continuaciÃ³n se plantea:</p>

<font color=red><h4 align="center">#(ABC)</h4></font>

<p>donde el sÄ±Ìmbolo # indica que la primera letra dentro del parÃ©ntesis es un nodo
y los otros caracteres representan a los hijos del nodo, como se muestra en la
figura 7 :</p>

Figura 7.

<font color=yellow><h4 align="center">DefiniciÃ³n de lenguajes libres de contexto</h4></font>

<p>Una gramÃ¡tica es un conjunto finito de reglas para generar un conjunto infi-
nito de sentencias. En lenguaje natural, las sentencias estÃ¡n hechas de palabras
y en el lenguaje de programaciÃ³n las sentencias estÃ¡n hechas de tokens.
Las gramÃ¡ticas libres de contexto son una notaciÃ³n recursiva para describir
conjuntos de cadenas e imponer una estructura en cada una de las cadenas.
Esta notaciÃ³n puede en algunos casos ser traducida casi directamente en pro-
gramas recursivos, pero es mejor generar un autÃ³mata de pila. Esto es similar
al autÃ³mata finito del anÃ¡lisis lÃ©xico pero estos pueden usar adicionalmente una
pila, lo cual permite contar y acoplar no localmente de sÄ±Ìmbolos. Hay dos formas
de generar este autÃ³mata: LL y LR.</p>

DefiniciÃ³n 10.

DefiniciÃ³n 11.

<p>Se presentÃ³ la definiciÃ³n de estas gramÃ¡ticas por medio de la jerarquÄ±Ìa de
Chomsky. La gramÃ¡tica libre de contexto o gramÃ¡tica 2 tiene sus produc-
ciones de la forma:</p>

<font color=red><h4 align="center">A â†’ Î±</h4></font>

<p>donde A âˆˆ N y Î± âˆˆ V .
La gramÃ¡tica libre de contexto se expresa como:</p>

<font color=red><h4 align="center">G(N, T, P, S)</h4></font>

<p>y se dice que es una gramÃ¡tica libre de contexto, debido a que sus producciones
cumplen con la forma 2 de la jerarquÄ±Ìa de Chomsky.</p>

DefiniciÃ³n 12.

<header>
<h3 align="center" id=#arq>Tipos de analizadores sintÃ¡cticos</h3>
</header>

<p>Existen dos tipos de analizadores sintÃ¡cticos:</p>

1. Analizador sintÃ¡ctico descendente.
2. Analizador sintÃ¡ctico ascendente.

<font color=yellow><h4 align="center">AnÃ¡lisis sintÃ¡ctico descendente</h4></font>

<p>El analizador sintÃ¡ctico descendente comienza desde la raÄ±Ìz del Ã¡rbol de
anÃ¡lisis sintÃ¡ctico trata de reconstruir el crecimiento del Ã¡rbol que nos lleva a la
cadena de tokens. De modo que haciendo la derivaciÃ³n izquierda, en efecto los
pasos resultan en la forma sentencial de derivaciÃ³n, en orden inverso.
El anÃ¡lisis descendente se basa en gramÃ¡ticas LL que permiten analizar una
frase de entrada sin que existan bloqueos mutuos [6].</p>

<font color=yellow><h4 align="center">AnÃ¡lisis sintÃ¡ctico ascendente</h4></font>

<p>Este analizador tambiÃ©n se conoce como analizador por desplazamiento y
reducciÃ³n. Este analizador intenta construir un Ã¡rbol de anÃ¡lisis sintÃ¡ctico para
una cadena de entrada que comienza por las hojas (el fondo) y avanza hacia la
raÄ±Ìz (la cima) [3].</p>

<font color=yellow><h4 align="center">Primeros y siguientes</h4></font>

<p>Estos dos conjuntos de sÄ±Ìmbolos son importantes debido a que muestran los
caracteres mÃ¡s importantes de la cadena y nos auxiliarÃ¡n a plantear reglas que
facilitarÃ¡n la clasificaciÃ³n de las gramÃ¡ticas LL(1).
Para poder calcular los primeros y siguientes de una cadena de caracteres,
se basa en la utilizaciÃ³n de las producciones.</p>

DefibiciÃ³n 13.

EJEMPLO 16.

DefiniciÃ³n 14.

EJEMPLO 17.

<header>
<h3 align="center" id=#arq>Analizadores sintÃ¡cticos descendentes</h3>
</header>

<p>Para construir los analizadores sintÃ¡cticos descendentes se considera la for-
maciÃ³n del Ã¡rbol de anÃ¡lisis sintÃ¡ctico y existen dos casos:
Uno, las hojas del Ã¡rbol de anÃ¡lisis sintÃ¡ctico contiene solo sÄ±Ìmbolos ter-
minales, y la cadena de entrada se ha agotado. Es claro que el anÃ¡lisis tiene
Ã©xito.
Dos, un claro acoplamiento ocurre entre las hojas del Ã¡rbol de anÃ¡lisis
sintÃ¡ctico parcialmente construido y la cadena de entrada. Para este caso exis-
ten dos situaciones:
Una primer situaciÃ³n es, que el analizador pudo haber seleccionado la pro-
ducciÃ³n errÃ³nea en un paso anterior del proceso, en este caso se puede retroceder, sistemÃ¡ticamente reconsiderando decisiones anteriores. Para una cadena que es
una sentencia vÃ¡lida, el retroceso llevarÃ¡ al analizador a una secuencia correcta
de selecciones y permitirÃ¡ la construcciÃ³n de un Ã¡rbol de anÃ¡lisis sintÃ¡ctico co-
rrecto. La segunda situaciÃ³n es, que la cadena de entrada no es una sentencia
vÃ¡lida, el retroceso fallarÃ¡ y el analizador deberÃ¡ reportar el error al usuario.
Un gran subconjunto de gramÃ¡ticas libres de contexto pueden ser analizadas
sin retroceso [5].
Los analizadores sintÃ¡cticos descendentes son: el analizador sintÃ¡ctico por
descenso recursivo y el analizador sintÃ¡ctico LL(1).</p>

<font color=yellow><h4 align="center">ConstrucciÃ³n de analizadores sintÃ¡cticos por descenso re-
cursivo</h4></font>

<p>Para construir el analizador sintÃ¡ctico de descenso recursivo, conviene que
la gramÃ¡tica sea LL(1). Ya que algunas de las gramÃ¡ticas libres de contexto
(GLC) tienen problemas, como:</p>

1. RecursiÃ³n izquierda o recursividad izquierda.
2. AmbigÃ¼edad.
3. Retroceso (backtracking).

<p>Y aunque la mayorÄ±Ìa de las gramÃ¡ticas libres de contexto pueden ser anali-
zadas sin retroceso. Es necesario comprobar que la GLC sea LL(1). Para saber
que una GLC es LL(1) debe cumplir con los siguientes puntos:</p>

<p>PRIMERO, si las producciones tienen la forma A â†’ Ïƒ 1 |Ïƒ 2 |Ïƒ 3 deben cum-
plir con la regla P RIM ERO(Ïƒ 1 ) âˆ© P RIM ERO(Ïƒ 2 ) âˆ© P RIM ERO(Ïƒ 3 ) = Ï†.
Llamada regla UNO.
SEGUNDO, si las producciones tienen la forma X â†’ Ïƒ| deben cumplir
con la rgla P RIM ERO(X) âˆ© SIGU IEN T E(X) = Ï†. Llamada regla DOS</p>

MÃ©todo 2.

Algoritmo 1.

<p>El Ã¡rbol sintÃ¡ctico se da implÄ±Ìcitamente por la secuencia de llamadas a pro-
cedimientos. Una gramÃ¡tica libre de backtrack (retroceso) se puede tratar con
descenso recursivo. Una analizador con descenso recursivo se estructura como
un conjunto de procedimientos mutuamente recursivos, uno para cada no termi-
nal de la gramÃ¡tica. El procedimiento que corresponde a un no terminal A, que
reconoce un valor de A en la cadena de entrada. Para reconocer un no terminal
B en el lado derecho de A (A â†’ Î±AÎ²), el analizador invoca el procedimiento
correspondiente a B. AsÄ±Ì la gramÃ¡tica por si misma sirve como una guÄ±Ìa para la
implementaciÃ³n del analizador.</p>

EJEMPLO 18.

Cuadro2.

<font color=yellow><h4 align="center">GramÃ¡tica aumentada</h4></font>

<p>Se agrega la producciÃ³n T 0 â†’ T al inicio del conjunto de producciones, con
la finalidad de asegurar la aceptaciÃ³n de las cadenas de entrada que reconoce la
gramÃ¡tica G 6 . La gramÃ¡tica G 6 aumentada se muestra en el cuadro 3 .</p>

Cuadro 3.

<font color=yellow><h4 align="center">ObtenciÃ³n de los primeros y siguientes</h4></font>

<p>Se deben obtener los primeros y siguientes de la gramÃ¡tica G 6 , los cuales se
concentran en el cuadro 4 .</p>

Cuadro 4.

<font color=yellow><h4 align="center">ObtenciÃ³n de los procedimientos del anÃ¡lisis por descenso recursivo</h4></font>

<p>Se debe obtener un procedimiento para cada no terminal utilizando los pri-
meros y siguientes del cuadro 4 . Para el sÄ±Ìmbolo no terminal Tâ€™, que tiene como producciÃ³n T 0 â†’ T :</p>

Algoritmo 2.

<p>Para el sÄ±Ìmbolo no terminal T, que tiene como producciÃ³n T â†’ R|aT c:</p>

Algoritmo 3.

<p>Para el sÄ±Ìmbolo no terminal R, que tiene como producciÃ³n R â†’ bR|Î»:</p>

Algoritmo 4.

<font color=yellow><h4 align="center">AnÃ¡lisis de cadenas de entrada con el analizador de descenso recursivo</h4></font>

<p>Para analizar la cadena de entrada abbc, se van utilizando los procedimien-
tos de manera recursiva que se muestran en el cuadro 5 .</p>

Cuadro 5.

Ejercicio 2.

Ejercicio 3.

Cuadro 6.

Cuadro 7.

Cuadro8.

Algoritmo 5.

Algoritmo 6.

Algoritmo 7.

Algoritmo 8.

Algoritmo 9.

Algoritmo 10.

Algoritmo 11.

<p>AnÃ¡lisis de cadenas en un analizador de descenso recursivo.
de la cadena id * id + id, se muestra en el cuadro 9 :</p>

Cuadro 9.

<p>Se mete en una lista enlazada la cadena de entrada y se va leyendo carÃ¡cter
por carÃ¡cter por medio de la funciÃ³n de lectura SigCar(), en la columna PRO-
CEDIMIENTO del cuadro 9 se escribe la funciÃ³n o procedimiento del no
terminal hasta consumirse la funciÃ³n o procedimiento. La aceptaciÃ³n es cuan-
do coincide que en la lista de entrada aparece el sÄ±Ìmbolo $ y en la columna
PROCEDIMIENTO aparece Acep.</p>

<font color=red><h4 align="center">G â‡’ E â‡’ T E 0 â‡’ F T 0 E 0 â‡’ idT 0 E 0 â‡’ id âˆ— F T 0 E 0
â‡’ id âˆ— idT 0 E 0 â‡’ id âˆ— idÎ»E 0 â‡’ id âˆ— idE 0
â‡’ id âˆ— id + T E 0 â‡’ id âˆ— id + F T 0 E 0 â‡’ id âˆ— id + idT 0 E 0
â‡’ id âˆ— id + idÎ»E 0 â‡’ id âˆ— id + idÎ»Î» â‡’ id âˆ— id + id</h4></font>

<font color=yellow><h4 align="center">ConstrucciÃ³n de analizadores sintÃ¡cticos LL(1)</h4></font>

<p>Para estudiar este analizador se usan las gramÃ¡ticas libres de contexto, pero
no todas las gramÃ¡ticas libres de contexto son ideales. Las gramÃ¡ticas libres de
contexto que no tengan esa ventaja, deben ser adaptadas para poder programar
sin retroceso.
El analizador sintÃ¡ctico LL(1) es descendente. Para poder determinar si la
gramÃ¡tica es del tipo LL(1), debe cumplir con dos reglas:</p>

1. Regla UNO. Si la producciÃ³n es de la forma A â†’ Ïƒ 1 | Ïƒ 2 | Â· Â· Â· | Ïƒ n , se de-
be cumplir con la siguiente condiciÃ³n: P RIM ERO(Ïƒ 1 )âˆ©P RIM ERO(Ïƒ 2 )âˆ©
Â· Â· Â· âˆ© P RIM ERO(Ïƒ n ) = Î¦.
2. Regla DOS. Si la producciÃ³n es de la siguiente forma X â†’ Ïƒ | Î», se
aplica la siguiente condiciÃ³n P RIM ERO(X) âˆ© SIGU IEN T E(X) = Î¦

<p>Cuando una gramÃ¡tica no es LL(1), para convertirla en LL(1) se debe seguir
el siguiente procedimiento:</p>

1. Se aplican las reglas UNO y DOS, para determinar si es LL(1).
2. Se debe determinar si las producciones de la gramÃ¡tica tienen recursividad
izquierda. Esto se comprueba si las producciones tienen la siguiente forma
A â†’ AÎ± | Î².
3. Se debe eliminar la recursividad izquierda, haciendo la siguiente transfor-
maciÃ³n: A â†’ Î²A 0 , A 0 â†’ Î±A 0 | Î».

<p>El siguiente ejemplo muestra el procedimiento para construir el analizador
LL(1).</p>

EJEMPLO 19.

<font color=yellow><h4 align="center">Calcular los primeros y siguientes de los no terminales</h4></font>

<p>Se obtienen los primeros y siguientes de los no terminales de la gramÃ¡tica,
los cuales se muestran en el cuadro 10 .</p>

Cuadro 10.

<font color=yellow><h4 align="center">Comprobar si la gramÃ¡tica es LL(1)</h4></font>

<p>Se comprueba si la gramÃ¡tica G 7 es del tipo LL(1). Para esto se aplican las
reglas UNO y DOS, como a continuaciÃ³n se muestra. A la producciÃ³n 2 se le
aplica la regla UNO.</p>

<font color=red><h4 align="center">PRIMERO(w) âˆ© PRIMERO(Bv) =
{w} âˆ© {w} =
Î¦</h4></font>

<p>A la producciÃ³n 4 se aplica la regla DOS:</p>

<font color=red><h4 align="center">PRIMERO(E) âˆ© SIGUIENTE(E) =
{y} âˆ© {x, z} = Ï†</h4></font>

<p>A la producciÃ³n 5 se le aplica la regla DOS.</p>

<font color=red><h4 align="center">PRIMERO(F ) âˆ© SIGUIENTE(F ) =
{x} âˆ© {z} = Ï†</h4></font>

<p>La producciÃ³n 2 no cumple la regla UNO, debido a que tiene recursividad
izquierda. La forma de la producciÃ³n 2, es como sigue:</p>

<font color=red><h4 align="center">A â†’ AÎ±|Î²</h4></font>

<p>La producciÃ³n 2 se escribe a continuaciÃ³n:</p>

<font color=red><h4 align="center">B â†’ Bv|w</h4></font>

<font color=yellow><h4 align="center">Convertir la gramÃ¡tica en LL(1)</h4></font>

<p>Para hacer que la producciÃ³n 2 cumpla con la regla UNO, se elimina la
recursividad izquierda haciendo la siguiente transformaciÃ³n:</p>

<font color=red><h4 align="center">A = B, A 0 = B 0 , Î± = v, Î² = w</h4></font>

<p>Estos valores se substituyen en las siguientes producciones:</p>

<font color=red><h4 align="center">A â†’ Î²A 0
A 0 â†’ Î±A 0 |&epsilon;</h4></font>

<p>La producciÃ³n 2 se cambia por la producciÃ³n 2 sin recursividad en la gramÃ¡ti-
ca. La producciÃ³n 2 sin recursividad izquierda es la siguiente:</p>

<font color=red><h4 align="center">B â†’ wB 0
B 0 â†’ vB 0 |&epsilon;</h4></font>

<p>La gramÃ¡tica G<SUB>7</SUB> y sin recursividad izquierda, se presenta a continuaciÃ³n:</p>

1. S â†’ uBDz
2. B â†’ wB 0
3. B 0 â†’ vB 0 |&epsilon;
4. D â†’ EF
5. E â†’ y
6. E â†’ &epsilon;
7. F â†’ x
8. F â†’ &epsilon;

<p>A la producciÃ³n 3 se le aplica la regla DOS:</p>

<font color=red><h4 align="center">PRIMERO(B 0 ) âˆ© SIGUIENTE(B 0 ) =
{v} âˆ© {y, z} = Ï†</h4></font>

<p>Como la producciÃ³n 3 cumple con la regla DOS, la gramÃ¡tica G 7 es ahora
una gramÃ¡tica LL(1). La gramÃ¡tica G 7 expandida es:</p>

1. S â†’ uBDz
2. B â†’ wB 0
3. B 0 â†’ vB 0
4. B 0 â†’ &epsilon;
5. D â†’ EF
6. E â†’ y
7. E â†’ &epsilon;
8. F â†’ x
9. F â†’ &epsilon;

<p>La nueva tabla de primeros y siguientes es la que se muestra en el cuadro 11 :</p>

Cuadro 11.

<font color=yellow><h4 align="center">ConstrucciÃ³n de la tabla LL(1)</h4></font>

<p>Para llenar el cuadro 12 , se utilizan los primeros y siguientes del cuadro
10 . Para las producciones que no generan la cadena vacÄ±Ìa de la gramÃ¡tica G 7
expandida se usan los primeros. Para las producciones que generan la cadena
vacÄ±Ìa se usan los siguientes.</p>

Cuadro12.

<font color=yellow><h4 align="center">AnÃ¡lisis de cadenas de entrada con un analizador LL(1)</h4></font>

<p>Se analiza la cadena de entrada uwvyxz y el anÃ¡lisis se muestra en el cua-
dro 13 :</p>

Cuadro13.

<p>La cadena de entrada se mete a una lista enlazada y de esta lista se va
leyendo carÃ¡cter por carÃ¡cter por medio de la funciÃ³n SigCar(). En la pila se
mete el sÄ±Ìmbolo $ y el sÄ±Ìmbolo inicial de la gramÃ¡tica y en la columna del cuadro
13 se escribe el nÃºmero de producciÃ³n utilizada. La flecha indica que se aplica
un pop() a la pila. Cuando aparece la producciÃ³n indicada por el nÃºmero que
se escribe en la columna NUM PRODUCCIÃ“N, se cambia el sÄ±Ìmbolo no terminal por su equivalencia que se expresa en la parte derecha del nÃºmero de
producciÃ³n que se indica con el nÃºmero.</p>

<p>ProgramaciÃ³n del analizador LL(1). La forma de programar una gramÃ¡ti-
ca LL(1), se hace de la siguiente forma:</p>

Algoritmo 12.

<font color=yellow><h4 align="center">Ejemplo de construcciÃ³n de un analizador sintÃ¡ctico descendente</h4></font>

<p>Se muestra la gramÃ¡tica libre de contexto G 8 en el cuadro 14 :</p>

Cuadro 14.

<p>Basados en la gramÃ¡tica G 8 construir los analizadores LL(1) y el descenso recursivo. Primero se comprueba que la gramÃ¡tica es LL(1), como se muestra a
continuaciÃ³n:
Se aplican la regla UNO a las producciones 2 y 3. Para la producciÃ³n 2:</p>

<font color=red><h4 align="center">PRIMERO(aa) âˆ© PRIMERO(a) 6 = Ï†
{a} âˆ© {a} = Ï†</h4></font>

<p>Se aplica la regla UNO a la producciÃ³n 3:</p>

<font color=red><h4 align="center">PRIMERO(b) âˆ© PRIMERO(ac) = Ï†
{b} âˆ© {a} = Ï†</h4></font>

<p>Como la producciÃ³n 2 no cumple con la regla UNO. Entonces la gramÃ¡tica
se debe transformar en LL(1). Para cumplir con la caracterÄ±Ìstica de gramÃ¡tica
LL(1), se transforma la producciÃ³n 2 como sigue:</p>

<font color=red><h4 align="center">A â†’ aa|a</h4></font>

<p>Se factoriza como se muestra a continuaciÃ³n:</p>

<font color=red><h4 align="center">A â†’ a(a|Î»)
A â†’ aC
C â†’ a|Î»</h4></font>

<p>Ahora, a la producciÃ³n C â†’ a|Î», se la aplica la regla DOS:</p>

<font color=red><h4 align="center">PRIMERO(C) âˆ© SIGUIENTE(C)
{a} âˆ© {a, b} =
Ï†</h4></font>

<p>Como no se puedo corregir, entonces se procede a reescribir la gramÃ¡tica. Se
comienza con la producciÃ³n 1, como se muestra en seguida:</p>

<font color=red><h4 align="center">S â†’ AB</h4></font>

<p>En la producciÃ³n 1 se substituyen las producciones 2 y 3 como se muestra:</p>

<font color=red><h4 align="center">S â†’ (aa|a)(b|ac)</h4></font>

<p>Haciendo las operaciones en la parte derecha de la producciÃ³n queda de la
siguiente forma:</p>

<font color=red><h4 align="center">S â†’ (aa|a)(b|ac)</h4></font>

<p>Haciendo las operaciones en la parte derecha de la producciÃ³n queda de la
siguiente forma:</p>

<font color=red><h4 align="center">S â†’ aab|aaac|ab|aac</h4></font>

<p>Se factoriza la producciÃ³n del no terminal S y queda como sigue:</p>

<font color=red><h4 align="center">S â†’ a(ab|aac|b|ac)
S â†’ aD
D â†’ ab|aac|b|ac</h4></font>

<p>Se factoriza la producciÃ³n del no terminal D y queda como sigue:</p>

<font color=red><h4 align="center">D â†’ a(ac|b|c)|b
D â†’ aE|b
E â†’ ac|b|c</h4></font>

<p>Por lo que la gramÃ¡tica convertida a LL(1) se muestra en el cuadro 15 :</p>

Cuadro 15.

<p>Analizador LL(1). Primero se obtiene la tabla de primeros y siguientes que
se muestra en 16 :</p>

Cuadro 16.

<p>Con el apoyo de la tabla 16 se obtiene la tabla LL(1) que se muestra en la
tabla 17 :</p>

Cuadro 17.

<p>Se analiza la cadena aab usando el cuadro 17 de donde se obtiene el cuadro
de anÃ¡lisis 18 :</p>

Cuadro 18.

<p>Analizador de descenso recursivo. Lo primero que se hace es aumentar la
gramÃ¡tica la cual se muestra en el cuadro 19 :</p>

Cuadro19.

<p>Se obtiene la tabla de primeros y siguientes que se muestra en el cuadro 20 :</p>

Cuadro20.

<p>Apoyados en la gramÃ¡tica G 8 y la tabla de primeros y siguientes del cuadro
20 , se obtienen las funcionas para cada uno de los no terminales G, S, D, E de la gramÃ¡tica. Para la producciÃ³n G â†’ S:</p>

Algoritmo 13.

<p>Para la producciÃ³n S â†’ aD la funciÃ³n es la siguiente:</p>

Algoritmo 14.

<p>Para las producciones D â†’ aE y D â†’ b la funciÃ³n es la siguiente:</p>

Algoritmo 15.

<p>Para las producciones E â†’ ac, E â†’ b, E â†’ c la funciÃ³n es la siguiente:</p>

Algoritmo 16.

<p>Analizar con las funciones la cadena aab, el anÃ¡lisis se muestra en el cuadro
21 :</p>

Cuadro 21.

<font color=yellow><h4 align="center">Ejercicios propuestos de analizadores sintÃ¡cticos descen-
dentes</h4></font>

<p>Resolver los siguientes ejercicios por medio de la metodologÄ±Ìa de LL(1) y de
descenso recursivo:</p>

Ejercicio 1.

Cuadro 22.

Ejercicio 2.

Cuadro 23.

Ejercicio3.

Cuadro 24.

Ejercicio 4.

Cuadro 25.

<p>ConstrucciÃ³n del analizador LL(1) de la gramÃ¡tica del ejercicio 4.
Se comprueba que la gramÃ¡tica sea LL(1), aplicando las reglas UNO y DOS.
Solamente se aplican para las producciones que tienen alternativas, es el caso
de las producciones 2, 3 y 4. Para la producciÃ³n 2 se aplica la regla UNO:</p>

<font color=red><h4 align="center">PRIMERO(T ) âˆ© PRIMERO(EM T ) =
{PRIMERO(T )} âˆ© {PRIMERO(T ), PRIMERO(E)} = Ï†</h4></font>

<p>La producciÃ³n 2 no cumple la regla UNO, se debe corregir. Para la pro-
ducciÃ³n 3 se aplica la regla DOS ya que el no terminal M genera la cadena
vacia:</p>

<font color=red><h4 align="center">PRIMERO(M ) âˆ© SIGUIENTE(M ) =
{âˆ—} âˆ© {PRIMERO(T )}
{âˆ—} âˆ© {i, n} = Ï†</h4></font>

<p>La producciÃ³n 3 si cumple con la regla DOS. Para la producciÃ³n 4 se aplica
la regla UNO:</p>

<font color=red><h4 align="center">PRIMERO(i) âˆ© PRIMERO(n) =
{i} âˆ© {n} = Ï†</h4></font>

<p>La producciÃ³n 4 si cumple con la regla UNO. AsÄ±Ì que se procede a corregir
a la producciÃ³n 2, la cual presenta la recursividad izquierda. Por lo que para
corregirla se aplica la eliminaciÃ³n de la recursividad izquierda.
Se usa la producciÃ³n de la forma general de la recursividad izquierda, se
compara para determinar las igualdades y usar la transformaciÃ³n para eliminar
la recursividad izquierda, de la siguiente manera:</p>

<font color=red><h4 align="center">A â†’ AÎ±|Î²
E â†’ EMT |T</h4></font>

<p>Las igualdades que se obtienen son :</p>

<font color=red><h4 align="center">A = E, A 0 = E 0 , Î± = M T, Î² = T</h4></font>

<p>Se aplica la transformaciÃ³n:</p>

<font color=red><h4 align="center">A â†’ Î²A 0
A 0 â†’ Î±A 0 |Î»</h4></font>

<p>Y se obtienen las producciones ya corregidas:</p>

<font color=red><h4 align="center">E â†’ T E'
E' â†’ M T E' |Î»</h4></font>

<p>AsÄ±Ì que la gramÃ¡tica queda como se muestra en el cuadro 26 :</p>

Cuadro26.

<p>Se procede a aplicar la regla DOS a la producciÃ³n 3 de la gramÃ¡tica del
cuadro 26 :</p>

<font color=red><h4 align="center">PRIMERO(E 0 ) âˆ© SIGUIENTE(E 0 ) =
{i, n} âˆ© {$} = Ï†</h4></font>

<p>Ya que la producciÃ³n 3 cumple con la regla DOS, la gramÃ¡tica del cuadro
26 es LL(1). Por lo que para obtener su tabla LL(1). Se lista la gramÃ¡tica
expandida:</p>

Cuadro 27.

<p>De la gramÃ¡tica del cuadro 27 se obtienen los primeros y siguientes de los
no terminales que se muestran en el cuadro 28 :</p>

Cuadro28.

<p>La tabla LL(1) se obtiene basÃ¡ndose en el cuadro 27 de las producciones
y en el cuadro 28 de los primeros y siguientes, como se muestra en el cuadro
29 , donde se escriben las producciones a utilizar de acuerdo a los primeros y
siguientes de cada no terminal de la gramÃ¡tica corregida del ejercicio 4:</p>

Cuadro 29.

<p>Con el uso del cuadro 29 se analiza la cadena i*n*i, el anÃ¡lisis se describe
en el cuadro 30 :</p>

Cuadro 30.

<p>ConstrucciÃ³n del analizador por descenso recursivo de la gramÃ¡tica
corregida del ejercicio 4. La construcciÃ³n del analizador sintÃ¡ctico de des-
censo recursivo se inicia con el aumento de la gramÃ¡tica, la que se muestra en
el cuadro 31 :</p>

Cuadro 31.

<p>La gramÃ¡tica del cuadro 27 es una gramÃ¡tica aumentada, por lo que solo se
escribe otra vez la gramÃ¡tica en el cuadro 31 . La tabla de primeros y siguientes
es la que se muestra en el cuadro 28 . Las funciones se presentan a continuaciÃ³n, para la producciÃ³n S â†’ Z:</p>

Algoritmo 17.

<p>Ahora para la producciÃ³n Z â†’ E:</p>

Algoritmo 18.

<p>La funciÃ³n para la producciÃ³n E considerando la producciÃ³n E â†’ T E 0 es la
siguiente:</p>

Algoritmo 19.

<p>La funciÃ³n para el no terminal Eâ€™ considerando la producciÃ³n E 0 â†’ M T E 0 |Î» es la siguiente:</p>

Algoritmo 20.

<p>La funciÃ³n para el no terminal M considerando la producciÃ³n M â†’ âˆ—|Î» es
la siguiente:</p>

Algoritmo 21.

<p>La funciÃ³n para el no terminal T considerando la producciÃ³n T â†’ i|n es la
siguiente:</p>

Algoritmo 22.

<p>El siguiente paso es el anÃ¡lisis de cadenas utilizando las funciones ya cons-
truidas anteriormente. Se analiza la cadena i*n*i, el anÃ¡lisis se muestra en el
cuadro 32 :</p>

Cuadro 32.

Ejercicio 5.

Cuadro 33.

Ejercicio 6.

Cuadro 34.

Ejercicio 7.

Cuadro 35.

Ejercicio 8.

Cuadro 36.

Ejercicio 9.

Cuadro 37.

Ejercicio 10.

Cuadro 38.

<font color=yellow><h4 align="center">ConstrucciÃ³n de tablas</h4></font>

<p>Descubriendo la derivaciÃ³n de una cadena de entrada
El compilador debe inferir la derivaciÃ³n para una cadena de entrada. El pro-
ceso de construir una derivaciÃ³n de una sentencia de entrada se llama anÃ¡lisis.
Un analizador toma como entrada un presunto programa escrito en algÃºn len-
guaje fuente. El analizador ve el programa como este emerge del escaner: un
flujo de palabras acompaÃ±adas de su categorÄ±Ìa sintÃ¡ctica. Y la salida es una
derivaciÃ³n o un mensaje de error para el programa de entrada. Visualizar el anÃ¡lisis para construir un Ã¡rbol de anÃ¡lisis para el programa de entrada.
El analizador descendente se construye mediante un algoritmo que se imple-
menta con una derivaciÃ³n mÃ¡s a la izquierda, este Ã¡rbol de anÃ¡lisis anclado a la
variable raÄ±Ìz, usa una pila, con funciones de acceso push() y pop() para seguir
a la parte no acoplada de la periferia del Ã¡rbol.</p>

Algoritmo 23.

<p>ConstrucciÃ³n de tablas:</p>

Algoritmo 24.

<p>Aplicar la construcciÃ³n de tablas para construir el analizador sintÃ¡ctico, se hace de la siguiente forma:</p>

Algoritmo 25.

<header>
<h4 align="center">Analizadores sintÃ¡cticos ascendentes</h4>
</header>

<font color=yellow><h4 align="center">Analizadores LR(0)</h4></font>

<p>Este tipo de analizador se basa en las derivaciones por la derecha y la lectura
por la izquierda, lo que se expresa como LR(). Para este tipo de analizador se
deben obtener los elementos LR(0), los cuales se representan usando un punto
que indica la posiciÃ³n del anÃ¡lisis en las cadenas de las producciones. Si se tiene
la siguiente gramÃ¡tica:</p>

<font color=red><h4 align="center">E â†’ E + T |T
T â†’ T âˆ— F |F
F â†’ (E)|id</h4></font>

<font color=yellow><h4 align="center">Aumentar la gramÃ¡tica</h4></font>

<p>Se aumenta la gramÃ¡tica y se enumera.</p>

DefiniciÃ³n 15.

EJEMPLO 20.

Cuadro 39.

<font color=yellow><h4 align="center">Analizadores LR(0)</h4></font>

<p>Para comenzar a calcular los elementos LR(0) se hacen las siguientes defini-
ciones y se muestra el procedimiento.</p>

DefiniciÃ³n 16.

DefiniciÃ³n 17.

<p>Los elementos LR(0) se calculan de la siguiente manera. Se obtiene el estado
I 0 aplicando la operaciÃ³n de cerradura a la producciÃ³n aumentada:</p>

<font color=red><h4 align="center">0 = cerradura(E 0 â†’ â€¢E) = { E 0 â†’ â€¢E , E â†’ â€¢E + T , E â†’ â€¢T , T â†’ â€¢T âˆ— F , T â†’ â€¢F , F â€¢ (E) , F â†’ â€¢id }</h4></font>

<p>Se obtiene el estado I 1 aplicando la funciÃ³n de movimiento Ir a de I 0 con
E:</p>

<font color=red><h4 align="center">1 = Ir a(I 0 , E) = cerradura(E 0 â†’ E â€¢ , E â†’ E â€¢ +T ) = { E 0 â†’ E â€¢ ,
E â†’ E â€¢ +T }</h4></font>

<p>Se obtiene el estado I<SUB>2</SUB> aplicando la funciÃ³n de movimiento Ir a de I 0 con T:</p>

<font color=red><h4 align="center">I 2 = Ir a(I 0 , T ) = cerradura(E â†’ T â€¢ , T â†’ T â€¢ âˆ—F ) = { E â†’ T â€¢ ,
T â†’ T â€¢ âˆ—F }</h4></font>

<p>Se obtiene el estado I 3 aplicando la funciÃ³n de movimiento Ir a de I 0 con F:</p>

<font color=red><h4 align="center">I 3 = Ir a(I 0 , F ) = cerradura(T â†’ F â€¢) = { T â†’ F â€¢ }</h4></font>

<p>Se obtiene el estado I 4 aplicando la funciÃ³n de movimiento Ir a de I 0 con (:</p>

<font color=red><h4 align="center">I 4 = Ir a(I 0 , () = cerradura(F â†’ (â€¢E)) = { F â†’ (â€¢E) , E â†’ â€¢E+T , E â†’ â€¢T ,
T â†’ â€¢T âˆ— F , T â†’ â€¢F , F â€¢ (E) , F â†’ â€¢id }</h4></font>

<p>Se obtiene el estado I 5 aplicando la funciÃ³n de movimiento de Ir a de I 0 con id:</p>

<font color=red><h4 align="center">I 5 = Ir a(I 0 , id) = cerradura(F â†’ idâ€¢) = { F â†’ id â€¢ }</h4></font>

<p>Se obtiene el estado I 6 aplicando la funciÃ³n de movimiento de Ir a de I 1 con +:</p>

<font color=red><h4 align="center">I 6 = Ir a(I 1 , +) = cerradura(F â†’ E+â€¢T ) = { E â†’ E+â€¢T , T â†’ â€¢T âˆ—F , T â†’ â€¢F ,
F â†’ â€¢(E) }</h4></font>

<p>Se obtiene el estado I 7 aplicando la funciÃ³n de movimiento de Ir a de I 2 con *:</p>

<font color=red><h4 align="center">I 7 = Ir a(I 2 , âˆ—) = cerradura(T â†’ T âˆ—â€¢F ) = { T â†’ T âˆ—â€¢F , F â†’ â€¢(E) , F â†’ â€¢id }</h4></font>

<p>Se obtiene el estado I 8 aplicando la funciÃ³n de movimiento de Ir a de I 4 con E:</p>

<font color=red><h4 align="center">I 8 = Ir a (I 4 , E) = cerradura(F â†’ (Eâ€¢) , E â†’ E â€¢ +T ) = { F â†’ (Eâ€¢) ,
E â†’ E â€¢ +T }</h4></font>

<p>Se obtiene el estado I 9 aplicando la funciÃ³n de movimiento de Ir a de I 6 con T:</p>

<font color=red><h4 align="center">I 9 = Ir a(I 6 , T ) = cerradura(E â†’ E + T â€¢ , T â†’ T â€¢ âˆ—F ) = { E â†’ E + T â€¢ ,
T â†’ T â€¢ âˆ—F }</h4></font>

<p>Se obtiene el estado I 10 aplicando la funciÃ³n de movimiento de Ir a de I 7
con F:</p>

<font color=red><h4 align="center">I 10 = Ir a(I 7 , F ) = cerradura(T â†’ T âˆ— F â€¢) = { T â†’ T âˆ— F â€¢ }</h4></font>

<p>Se obtiene el estado I 11 aplicando la funciÃ³n de movimiento de Ir a de I 8
con ):</p>

<font color=red><h4 align="center">I 11 = Ir a(I 8 , )) = cerradura(F â†’ (E)â€¢) = { F â†’ (E) â€¢ }</h4></font>

<font color=yellow><h4 align="center">CÃ¡lculo de los primeros y siguientes</h4></font>

<p>Se obtienen los PRIMEROS y SIGUIENTES de todos los no terminales, los
cuales se muestran en el cuadro 40 :</p>

Cuadro 40.

<font color=yellow><h4 align="center">ConstrucciÃ³n del grafo</h4></font>

<p>Para obtener el grafo de los estados. Primero se observan los movimientos:
el movimiento de I 0 con E se va a I 1 . El movimiento de I 0 con T se va a I 2 .
El movimiento de I 0 con F se va a I 3 . El movimiento de I 0 con ( se va a I 4 . El
movimiento de I 0 con id se va a I 5 . El movimiento de I 1 con + se va a I 6 . El
movimiento de I 2 con * se va a I 7 . El movimiento de I 4 con E se va a I 8 . El
movimiento de I 6 con T se va a I 9 . El movimiento de I 7 con F se va a I 10 . El
movimiento de I 8 con ) se va a I 11 .</p>

DefiniciÃ³n 18.

<p>Segundo se aplica la continuidad en cada uno de los 12 estados, de la siguiente
forma: En el estado I 0 los elementos LR(0) tienen transiciones representadas en
el grafo. En el estado I 1 los elementos LR(0) tienen transiciones representadas en
el grafo. En el estado I 2 los elementos LR(0) tienen transiciones representadas en
el grafo. En el estado I 3 los elementos LR(0) tienen transiciones representadas en
el grafo. En el estado I 4 los elementos que no tienen transiciones representadas en el grafo son: E â†’ â€¢E + T se debe crear la transiciÃ³n con el sÄ±Ìmbolo + del
estado I 8 a I 6 . Para el elemento LR(0) E â†’ â€¢T se crea la transiciÃ³n con T
de I 4 a I 2 , por lo que con esto se crea la continuidad para el elemento LR(0)
T â†’ â€¢T âˆ— F . Para el elemento LR(0) T â†’ â€¢F se crea la transiciÃ³n con F de I 4 a
I 3 . Para el elemento LR(0) F â†’ â€¢(E) por lo que se crea la transiciÃ³n con ( de I 4
a I 4 , esto es un ciclo. Para el elemento LR(0) F â†’ â€¢id se crea la transiciÃ³n con id
de I 4 a I 5 . En el estado I 5 los elementos LR(0) tienen transiciones representadas
en el grafo. En el estado I 6 los elementos LR(0) que faltan de representaciÃ³n en
el grafo para F â†’ â€¢T âˆ— F la transiciÃ³n con * falta, asÄ±Ì que se crea la transiciÃ³n
con este sÄ±Ìmbolo entre I 9 e I 7 . En el estado I 7 los elementos LR(0) F â†’ â€¢(E)
el sÄ±Ìmbolo ( no tiene transiciÃ³n por lo que se crea de I 7 a I 4 , para el elemento
LR(0) F â†’ â€¢id no hay transiciÃ³n para el sÄ±Ìmbolo id entonces se crea de I 7 a I 5 .
Para el estado I 8 para el elemento LR(0) E â†’ E â€¢ +T falta la transiciÃ³n con el
sÄ±Ìmbolo + por lo que se crea del estado I 8 al estado I 6 . Para el estado I 9 se crea
la transiciÃ³n con el sÄ±Ìmbolo * del estado I 9 al estado I 7 . Los estados I 10 e I 11
ya no tienen transiciones. Con esto se cumple con el concepto de continuidad.
Todo esto se muestra en el grafo de la figura 8 .</p>

Figura 8.

<font color=yellow><h4 align="center">ObtenciÃ³n de las tablas ACCIÃ“N y de IR A</h4></font>

DefiniciÃ³n 19.

DefiniciÃ³n 20

DefiniciÃ³n 21.

DefiniciÃ³n 22.

DefiniciÃ³n 23.

<p>Las acciones que se reportan en la tabla de acciones, son la reducciÃ³n que
se representa con una r y como subÄ±Ìndice el nÃºmero de producciÃ³n, el despla-
zamiento que se representa por una d y como subÄ±Ìndice el estado al cuÃ¡l se
desplaza, la aceptaciÃ³n que se representa por acp y el error que se representa
con e. Se obtienen las tablas de AcciÃ³n y de IR A que se muestran en el cuadro
41 :</p>

Cuadro 41.

<font color=yellow><h4 align="center">AnÃ¡lisis de cadenas de entrada</h4></font>

<p>Se hace el anÃ¡lisis de la cadena de entrada id âˆ— id + id: la cadena de entrada
se coloca en la columna ENTRADA del cuadro 42, la flecha vertical indica que
se esta leyendo el sÄ±Ìmbolo que esta a la izquierda de dicha flecha. En la pila se
coloca el $ (eof) y el estado I 0 queda en la cima de la pila, que esta representada
en la columna PILA. Para determinar la acciÃ³n que se escribirÃ¡ en la columna
ACCIÃ“N, se consulta el cuadro de AcciÃ³n: se comienza en el estado I 0 y con el
sÄ±Ìmbolo de entrada id concurre la acciÃ³n d 5 , por lo que en la columna PILA se
escribe el sÄ±Ìmbolo id y el subÄ±Ìndice 5 quiere decir que en la cima de la pila se
escribe el estado I 5 , despuÃ©s se avanza la flecha vertical y queda a su izquierda
el sÄ±Ìmbolo *. Ahora en el estado I 5 y la concurrencia con el sÄ±Ìmbolo * se tiene
la acciÃ³n r 6 , que quiere decir que el sÄ±Ìmbolo id se transforma en F. Se consulta
la tabla IR A, por lo que un sÄ±Ìmbolo F en el estado I 0 se va al estado I 3 . En
el cuadro 42 se tiene todo el recorrido de la cadena de entrada hasta llegar a $,
donde se muestra como va cambiando el contenido de la pila.</p>

Cuadro 42.

<font color=yellow><h4 align="center">Ejercicios de analizadores LR(0)</h4></font>

<p>Construir el analizador LR(0) de las siguientes gramÃ¡ticas:</p>

Ejercicio 4.

Ejercicio 5.

Ejercicio 6.

Ejercicio 7.

<p>SoluciÃ³n a ejercicio 7. Se comienza aumentando la gramÃ¡tica y dividiÃ©ndola
en capas, como se muestra en el cuadro 43 :</p>

Cuadro 43.

<p>Se comienza a calcular los elementos LR(0) utilizando las operaciones de
cerradura y de Ir a, que se muestran en el cuadro 44 :</p>

Cuadro 44.

<p>Del conjunto de estados se obtiene el grafo que se muestra en la figura 9 .</p>

Figura 9.

<p>Aplicando la continuidad se obtiene el grafo completo que se muestra en la
figura 10 :</p>

Figura 10.

<p>Del grafo completo de la figura 10 se obtienen las tablas de acciÃ³n y de Ir a
que se muestra en el cuadro 45 :</p>

Cuadro 45.

<p>Con la tabla de acciÃ³n y de Ir a se hace el anÃ¡lisis de cadenas de entrada,
como se muestra con la cadena x = * x. Lo que se muestra en la tabla ?? :</p>

Ejercicio 8.

Ejercicio 9.

Ejercicio 10.

<font color=yellow><h4 align="center">Analizadores LR(1)</h4></font>

<p>La construcciÃ³n del analizador sintÃ¡ctico LR(1) al igual que el analizador
sintÃ¡ctico LR(0) es el mismo procedimiento, lo que se muestra a continuaciÃ³n.
Se tiene la siguiente gramÃ¡tica:</p>

1. S â†’ E = E
2. S â†’ f
3. E â†’ T
4. E â†’ E + T
5. T â†’ f
6. T â†’ T âˆ— f

<font color=yellow><h4 align="center">Aumentar la gramÃ¡tica</h4></font>

<p>El siguiente paso es aumentar la gramÃ¡tica y enumerar las producciones de
0 a 6, como se muestra en el cuadro 46 :</p>

Cuadro 46.

<font color=yellow><h4 align="center">Calcular los primeros y siguientes</h4></font>

<p>Se debe obtener la tabla de primeros y siguientes, los que se muestran en el
cuadro 47 :</p>

<font color=yellow><h4 align="center">Calcular los elementos LR(1)</h4></font>

<p>Los elementos LR(1) tienen la forma G â†’ Sâ€¢, $, donde este consta de un
nÃºcleo que es la producciÃ³n, se separa con una coma el nÃºcleo y los sÄ±Ìmbolos de
anÃ¡lisis, entre cada uno de los sÄ±Ìmbolos de anÃ¡lisis se separan por dos puntos
como sigue: T â†’ â€¢T âˆ— f, =: + : âˆ— . Los elementos LR(1) se calculan de la
siguiente manera. Se obtiene el estado I 0 aplicando la operaciÃ³n de cerradura a
la producciÃ³n aumentada:</p>

<font color=red><h4 align="center">I 0 = Cerr(G â†’ â€¢S, $) = { G â†’ â€¢S, $ , S â†’ â€¢E = E, $ , S â†’ â€¢f, $ ,
E â†’ â€¢T, =: + , E â†’ â€¢E + T, =: + , T â†’ â€¢f, =: + : âˆ— ,
T â†’ â€¢T âˆ— f, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I<SUB>1</SUB> aplicando la funciÃ³n de movimiento Ir a de I 0 con S:</p>

<font color=red><h4 align="center"> I<SUB>1</SUB> = Ir a(I 0 , S) = Cerr(G â†’ Sâ€¢, $) = { G â†’ Sâ€¢, $ }</h4></font>

<p>Se obtiene el estado I 2 aplicando la funciÃ³n de movimiento Ir a de I 0 con
E:</p>

<font color=red><h4 align="center">I 2 = Ir a(I 0 , E) = Cerr(E â†’ Eâ€¢ = E, $ , E â†’ E â€¢ +T, =: +)
= { E â†’ Eâ€¢ = E, $ , E â†’ E â€¢ +T, =: + }</h4></font>

<p>Se obtiene el estado I 3 aplicando la funciÃ³n de movimiento Ir a de I 0 con f:</p>

<font color=red><h4 align="center">I 3 = Ir a(I 0 , f ) = Cerr(S â†’ â€¢f, $ , T â†’ f â€¢, =: + : âˆ—)
= { S â†’ f â€¢, $ , T â†’ f â€¢, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I 4 aplicando la funciÃ³n de movimiento Ir a de I 0 con
T:</p>

<font color=red><h4 align="center">I 4 = Ir a(I 0 , T ) = Cerr(E â†’ T â€¢, =: + , T â†’ T â€¢ âˆ—f, =: + : âˆ—)
= { E â†’ T â€¢, =: + , T â†’ T â€¢ âˆ—f, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I 5 aplicando la funciÃ³n de movimiento Ir a de I 2 con
=:</p>

<font color=red><h4 align="center">I 5 = Cerr( Ir âˆ’ a(I 2 , =)) = Cerr(S â†’ E = â€¢E, $ ) = { S â†’ E = â€¢E, $ ,
E â†’ â€¢T, $ : + , T â†’ â€¢f, $ : + : âˆ— , T â†’ â€¢T âˆ— f, $ : + : âˆ— ,
E â†’ â€¢E + T, $ : + }</h4></font>

<p>Se obtiene el estado I 6 aplicando la funciÃ³n de movimiento Ir a de I 2 con
+:</p>

<font color=red><h4 align="center">I 6 = Ir a(I 2 , +) = Cerr( E â†’ E + â€¢T, =: $ ) = { E â†’ E + â€¢T, =: $ ,
T â†’ â€¢f, =: + : âˆ— , T â†’ â€¢T âˆ— f, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I 7 aplicando la funciÃ³n de movimiento Ir a de I 4 con *:</p>

<font color=red><h4 align="center">I 7 = Ir a(I 4 , âˆ—) = Cerr( T â†’ T âˆ— â€¢f, =: + : âˆ— ) =
{ T â†’ T âˆ— â€¢f, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I 8 aplicando la funciÃ³n de movimiento Ir a de I 5 con
E:</p>

<font color=red><h4 align="center">I 8 = Ir a(I 5 , E) = Cerr( S â†’ E = Eâ€¢, $ , E â†’ E â€¢ +T, $ : + ) =
{ S â†’ E = Eâ€¢, $ , E â†’ E â€¢ +T, $ : + }</h4></font>

<p>Se obtiene el estado I 9 aplicando la funciÃ³n de movimiento Ir a de I 6 con
T:</p>

<font color=red><h4 align="center">I 9 = Ir a(I 6 , T ) = Cerr( E â†’ E+T â€¢ , = : + ; T â†’ T â€¢âˆ—f , = : + : âˆ— ) =
{ E â†’ E + T â€¢ , = : + ; T â†’ T â€¢ âˆ—f , = : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 10 aplicando la funciÃ³n de movimiento Ir a de I 7 con
f:</p>

<font color=red><h4 align="center">I 10 = Ir a(I 7 , f ) = Cerr( T â†’ T âˆ— f â€¢ , = : + : âˆ— ) =
{ T â†’ T âˆ— f â€¢ , = : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 11 aplicando la funciÃ³n de movimiento Ir a de I 5 con
T:</p>

<font color=red><h4 align="center">I 11 = Ir a(I 5 , T ) = Cerr( E â†’ T â€¢ , $ : + ; T â†’ T â€¢ âˆ—f , $ : + : âˆ— ) =
{ E â†’ T â€¢ , $ : + ; T â†’ T â€¢ âˆ—f , $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 12 aplicando la funciÃ³n de movimiento Ir a de I 5 con
T:</p>

<font color=red><h4 align="center">I 12 = Ir a(I 5 , f ) = Cerr( T â†’ f â€¢ , $ : + : âˆ— ) =
{ T â†’ f â€¢ , $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 13 aplicando la funciÃ³n de movimiento Ir a de I 11 con
*:</p>

<font color=red><h4 align="center">I 13 = Ir a(I 11 , âˆ—) = Cerr( T â†’ T âˆ— â€¢f , $ : + : âˆ— ) =
{ T â†’ T âˆ— â€¢f , $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 14 aplicando la funciÃ³n de movimiento Ir a de I 13 con
f:</p>

<font color=red><h4 align="center">I 14 = Ir a(I 13 , f ) = Cerr( T â†’ T âˆ— f â€¢ , $ : + : âˆ— ) =
{ T â†’ T âˆ— f â€¢ , $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 15 aplicando la funciÃ³n de movimiento Ir a de I 8 con
+:</p>

<font color=red><h4 align="center">I 15 = Ir a(I 8 , +) = Cerr( E â†’ E + â€¢T , $ : + ) =
{ E â†’ E + â€¢T , $ : + ; T â†’ â€¢f , $ : + : âˆ— ; T â†’ â€¢T âˆ— f , $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 16 aplicando la funciÃ³n de movimiento Ir a de I 15 con
T:</p>

<font color=red><h4 align="center">I 16 = Ir a(I 15 , T ) = Cerr( E â†’ E +T â€¢ , $ : + ; T â†’ T â€¢âˆ—f , $ : + : âˆ— ) =
{ E â†’ E + T â€¢ , $ : + ; T â†’ T â€¢ âˆ—f , $ : + : âˆ— }</h4></font>

<font color=yellow><h4 align="center">Construir el grafo del analizador LR(1)</h4></font>

<p>Ahora se comienza a revisar la continuidad desde el estado I 0 . Si el elemento
LR(1) no se acopla a un estado, se le debe crear un estado nuevo:
El estado I 0 es continuo. Ya que para cada sÄ±Ìmbolo que esta a la derecha del
punto de anÃ¡lisis existe un arco en el grafo. El estado I 1 tambiÃ©n es continuo.
Para el estado I 2 tambiÃ©n es continuo. TambiÃ©n el estado I 3 es continuo. La
diferencia en este paso de crear el grafo con el analizador LR(0) es que aquÄ±Ì se
crean estados y arcos, por lo que siguiendo el proceso, se obtiene el grafo de la
figura 11.</p>

Figura 11.

<font color=yellow><h4 align="center">ObtenciÃ³n de las tablas ACCIÃ“N y de IR A del analizador LR(1)</h4></font>

<p>Del grafo de la figura 11, se obtiene la tabla del analizador LR(1) que se
muestra en el cuadro 48:</p>

Cuadro 48.

<font color=yellow><h4 align="center">AnÃ¡lisis de cadenas de entrada con el analizador LR(1)</h4></font>

<p>Se hace el anÃ¡lisis de la cadena de entrada f = f âˆ—f +f : la cadena de entrada
se coloca en la columna ENTRADA del cuadro 49, la flecha vertical indica que
se esta leyendo el sÄ±Ìmbolo que esta a la derecha de dicha flecha. En la pila se
coloca el $ (eof) y el estado I 0 queda en la cima de la pila, que esta representada
en la columna PILA. Para determinar la acciÃ³n que se escribirÃ¡ en la columna
ACCIÃ“N, se consulta el cuadro de AcciÃ³n: se comienza en el estado I 0 y con
el sÄ±Ìmbolo de entrada f concurre la acciÃ³n d 3 , por lo que en la columna PILA
se escribe el sÄ±Ìmbolo f y el subÄ±Ìndice 3 quiere decir que en la cima de la pila se
escribe el estado I 3 , despuÃ©s se avanza la flecha vertical y queda a su izquierda
el sÄ±Ìmbolo f. Ahora en el estado I 3 y la concurrencia con el sÄ±Ìmbolo f se tiene
la acciÃ³n r 5 , que quiere decir que el sÄ±Ìmbolo f se transforma en T. Se consulta
la tabla IR A, por lo que un sÄ±Ìmbolo T en el estado I 0 se va al estado I 4 . En
el cuadro 49 se tiene todo el recorrido de la cadena de entrada hasta llegar al
sÄ±Ìmbolo $, donde se muestra como va cambiando el contenido de la pila.</p>

Cuadro 49.

<font color=yellow><h4 align="center">Ejercicios LR(1)</h4></font>

Ejercicio 11.

Ejercicio 12.

<font color=yellow><h4 align="center">Analizadores LALR</h4></font>

<p>Este mÃ©todo de analizar es mÃ¡s poderoso pero similar que un analizador
SLR(1), porque usa un anÃ¡lisis por adelantado el cual puede ser obtenido del
proceso de construcciÃ³n LR(1). Aunque el LALR(1) no es mÃ¡s poderoso que
un LR(1), la ventaja que tiene es que requiere menos espacio para su tabla de
anÃ¡lisis que el mismo LR(1) [7].
La construcciÃ³n del analizador sintÃ¡ctico LALR al igual que el analizador
sintÃ¡ctico LR(1) tiene el mismo procedimiento. El procedimiento se muestra a
continuaciÃ³n con la misma gramÃ¡tica que LR(1) que ya se analizÃ³:</p>

1. S â†’ E = E
2. S â†’ f
3. E â†’ T
4. E â†’ E + T
5. T â†’ f
6. T â†’ T âˆ— f

<font color=yellow><h4 align="center">Aumentar la gramÃ¡tica</h4></font>

<p>El siguiente paso es aumentar la gramÃ¡tica y enumerar las producciones de
0 a 6, que se muestran en el cuadro 50 :</p>

Cuadro 50.

<font color=yellow><h4 align="center">Tabla de primeros y siguientes</h4></font>

<p>Se debe obtener la tabla de primeros y siguientes, que se muestran en el
cuadro 51 :</p>

Cuadro 51.

<font color=yellow><h4 align="center">Elementos LR(1)</h4></font>

<p>Se obtienen los elementos LR(1), los cuales ya se calcularon en la parte del
analizador LR(1) y se presentan a continuaciÃ³n otra vez:</p>


<p>El estado I 0 :</p>

<font color=red><h4 align="center">I 0 = { G â†’ â€¢S, $ , S â†’ â€¢E = E, $ , S â†’ â€¢f, $ ,
E â†’ â€¢T, =: + , E â†’ â€¢E + T, =: + , T â†’ â€¢f, =: + : âˆ— ,
T â†’ â€¢T âˆ— f, =: + : âˆ— }</h4></font>

<p>El estado I 1 :</p>

<font color=red><h4 align="center">I 1 = { G â†’ Sâ€¢, $ }</h4></font>

<p>El estado I 2 :</p>

<font color=red><h4 align="center">I 2 = { E â†’ Eâ€¢ = E, $ , E â†’ E â€¢ +E, =: + }</h4></font>

<p>El estado I 3 :</p>

<font color=red><h4 align="center">I 3 = { S â†’ f â€¢, $ , T â†’ f â€¢, =: + : âˆ— }</h4></font>

<p>El estad I 4 :</p>

<font color=red><h4 align="center">I 4 = { E â†’ T â€¢, =: + , T â†’ T â€¢ âˆ—T, =: + : âˆ— }</h4></font>

<p>El estado I 5 :</p>

<font color=red><h4 align="center">I 5 = { S â†’ E = â€¢E, $ ,
E â†’ â€¢T, $ : + , T â†’ â€¢f, $ : + : âˆ— , T â†’ â€¢T âˆ— f, $ : + : âˆ— ,
E â†’ â€¢E + T, $ : + }</h4></font>

<p>El estado I 6 : </p>

<font color=red><h4 align="center">I 6 = { E â†’ E + â€¢T, =: $ ,
T â†’ â€¢f, =: + : âˆ— , T â†’ â€¢T âˆ— f, =: + : âˆ— }</h4></font>

<p>El estado I 7 :</p>

<font color=red><h4 align="center">I 7 = { T â†’ T âˆ— â€¢f, =: + : âˆ— }</h4></font>

<p>El estado I 8 :</p>

<font color=red><h4 align="center">I 8 = { S â†’ E = Eâ€¢, $ , E â†’ E â€¢ +T, $ : + }</h4></font>

<p>El estado I 9 :</p>

<font color=red><h4 align="center">I 9 = { E â†’ E + E â€¢ , = : + ; T â†’ T â€¢ âˆ—f , = : + : âˆ— }</h4></font>

<p>El estado I 10:</p>

<font color=red><h4 align="center">I 10 = { T â†’ T âˆ— f â€¢ , = : + : âˆ— }</h4></font>

<p>El estado I 11 :</p>

<font color=red><h4 align="center">I 11 = { E â†’ T â€¢ , $ : + ; T â†’ T â€¢ âˆ—f , $ : + : âˆ— }</h4></font>

<p>El estado I 12 :</p>

<font color=red><h4 align="center">I 12 = { T â†’ f â€¢ , $ : + : âˆ— }</h4></font>

<p>El estado I 13 :</p>

<font color=red><h4 align="center">I 13 = { T â†’ T âˆ— â€¢f , $ : + : âˆ— }</h4></font>

<p>El estado I 14 :</p>

<font color=red><h4 align="center">I 14 = { T â†’ T âˆ— f â€¢ , $ : + : âˆ— }</h4></font>

<p>El estado I 15 :</p>

<font color=red><h4 align="center">I 15 = { E â†’ E +â€¢T , $ : + ; T â†’ â€¢f , $ : + : âˆ— ; T â†’ â€¢T âˆ—f , $ : + : âˆ— }</h4></font>

<p>El estado I 16 : </p>

<font color=red><h4 align="center">I 16 = { E â†’ E + T â€¢ , $ : + ; T â†’ T â€¢ âˆ—f , $ : + : âˆ— }</h4></font>

<font color=yellow><h4 align="center">UniÃ³n de estados</h4></font>

<p>El siguiente paso es unir los nÃºcleos de los siguientes estados.
La uniÃ³n de los estados I 6 e I 15 , se convierte en el estado I 6</p>

<font color=red><h4 align="center">I 6 = { E â†’ E+â€¢T , = : $ : + ; T â†’ â€¢f , = : $ : + : âˆ— ; T â†’ â€¢T âˆ—f , = : $ : + : âˆ— }</h4></font>

<p>La uniÃ³n de los estados I 4 e I 11 , se convierte en el estado I 4 :</p>

<font color=red><h4 align="center">I 4 = { E â†’ T â€¢ , = : $ : + ; T â†’ T â€¢ âˆ—f , = : $ : + : âˆ— }</h4></font>

<p>La uniÃ³n de los estados I 10 e I 14 , se convierte en el estado I 10 :</p>

<font color=red><h4 align="center">I 10 = { T â†’ T âˆ— f â€¢ , = : $ : + : âˆ— }</h4></font>

<p>La uniÃ³n de los estados I 9 e I 16 , se convierte en el estado I 9 :</p>

<font color=red><h4 align="center">I 9 = { E â†’ E + T â€¢ , = : $ : + ; T â†’ T â€¢ âˆ—f , = : $ : + : âˆ— }</h4></font>

<p>La uniÃ³n de los estado I 7 e I 13 , se convierte en el estado I 7 :</p>

<font color=red><h4 align="center">I 7 = { T â†’ T âˆ— â€¢f , = : $ : + : âˆ— }</h4></font>

<font color=yellow><h4 align="center">FormaciÃ³n de estados</h4></font>

<p>AsÄ±Ì que ahora los estados quedan como a continuaciÃ³n se presentan:
Se obtiene el estado I 0 aplicando la operaciÃ³n de cerradura a la producciÃ³n
aumentada:</p>

<font color=red><h4 align="center">I 0 = Cerr(G â†’ â€¢S, $) = { G â†’ â€¢S, $ , S â†’ â€¢E = E, $ , S â†’ â€¢f, $ ,
E â†’ â€¢T, =: + , E â†’ â€¢E + T, =: + , T â†’ â€¢f, =: + : âˆ— ,
T â†’ â€¢T âˆ— f, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I 1 aplicando la funciÃ³n de movimiento Ir a de I 0 con S:</p>

<font color=red><h4 align="center">I 1 = Ir a(I 0 , S) = Cerr(G â†’ Sâ€¢, $) = { G â†’ Sâ€¢, $ }</h4></font>

<p>Se obtiene el estado I 2 aplicando la funciÃ³n de movimiento Ir a de I 0 con
E:</p>

<font color=red><h4 align="center">I 2 = Ir a(I 0 , E) = Cerr(E â†’ Eâ€¢ = E, $ , E â†’ E â€¢ +E, =: +)
= { E â†’ Eâ€¢ = E, $ , E â†’ E â€¢ +T, =: + }</h4></font>

<p>Se obtiene el estado I 3 aplicando la funciÃ³n de movimiento Ir a de I 0 con f:</p>

<font color=red><h4 align="center">I 3 = Ir a(I 0 , f ) = Cerr(S â†’ â€¢f, $ , T â†’ f â€¢, =: + : âˆ—)
= { S â†’ f â€¢, $ , T â†’ f â€¢, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I 4 aplicando la funciÃ³n de movimiento Ir a de I 0 con
T:</p>

<font color=red><h4 align="center">I 4 = Ir a(I 0 , T ) = { E â†’ T â€¢, =: + , T â†’ T â€¢ âˆ—T, =: + : âˆ— }</h4></font>

<p>Se obtiene el estado I 5 aplicando la funciÃ³n de movimiento Ir a de I 2 con
=:</p>

<font color=red><h4 align="center">I 5 = Ir a(I 2 , =) = { S â†’ E = â€¢E, $ ,
E â†’ â€¢T, $ : + , T â†’ â€¢f, $ : + : âˆ— , T â†’ â€¢T âˆ— f, $ : + : âˆ— ,
E â†’ â€¢E + T, $ : + }</h4></font>

<p>Se obtiene el estado I 6 aplicando la funciÃ³n de movimiento Ir a de I 2 con
+:</p>

<font color=red><h4 align="center">I 6 = Ir a(I 2 , +) = { E â†’ E + â€¢T , = : $ : + ;
T â†’ â€¢f , = : $ : + : âˆ— ; T â†’ â€¢T âˆ— f , = : $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 7 aplicando la funciÃ³n de movimiento Ir a de I 4 con *:</p>

<font color=red><h4 align="center">I 7 = Ir a(I 4 , âˆ—) = { T â†’ T âˆ— â€¢f , = : $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 8 aplicando la funciÃ³n de movimiento Ir a de I 5 con
E:</p>

<font color=red><h4 align="center">I 8 = Ir a(I 5 , E) = Cerr( S â†’ E = Eâ€¢, $ , E â†’ E â€¢ +T, $ : + ) =
{ S â†’ E = Eâ€¢, $ ; E â†’ E â€¢ +T, $ : + }</h4></font>

<p>Se obtiene el estado I 9 aplicando la funciÃ³n de movimiento Ir a de I 6 con
T:</p>

<font color=red><h4 align="center">I 9 = Ir a(I 6 , T ) = { E â†’ E+T â€¢ , = : $ : + ; T â†’ T â€¢âˆ—f , = : $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 10 aplicando la funciÃ³n de movimiento Ir a de I 7 con
f:</p>

<font color=red><h4 align="center">I 10 = Ir a(I 7 , f ) = { T â†’ T âˆ— f â€¢ , = : $ : + : âˆ— }</h4></font>

<p>Se obtiene el estado I 11 aplicando la funciÃ³n de movimiento Ir a de I 5 con
f:</p>

<font color=red><h4 align="center">I 11 = Ir a(I 5 , f ) = Cerr( T â†’ f â€¢ , $ : + : âˆ— ) =
{ T â†’ f â€¢ , $ : + : âˆ— }</h4></font>

<font color=yellow><h4 align="center">ConstrucciÃ³n del grafo</h4></font>

<p>Posteriormente se obtiene el grafo que se presenta en la figura 12, aplicÃ¡ndose
continuidad:</P>

Figura 12.

<font color=yellow><h4 align="center">ConstrucciÃ³n de las tablas ACCIÃ“N e IR A</h4></font>

<p>Del grafo y de los elementos de los estados de I 0 a I 11 se obtienen las tablas
de ACCIÃ“N y de IR A, que se presentan en el cuadro 52 .</p>

Cuadro 52.

<font color=yellow><h4 align="center">AnÃ¡lisis de cadenas</h4></font>

<p>La tabla de anÃ¡lisis de la cadena de entrada f = f + f âˆ— f es la que se
presenta en el cuadro 53.</p>

Cuadro 53.

<font color=yellow><h4 align="center">Conflictos</h4></font>

<p>Existen conflictos de desplazamiento/reducciÃ³n y conflicto de reducciÃ³n/-
reducciÃ³n. Cuando surge un conflicto desplazamiento/reducciÃ³n, el conflicto se
resuelve a favor del desplazamiento. En el caso del conflicto reducciÃ³n/reducciÃ³n
el conflicto se resuelve a favor de la reducciÃ³n que usa la producciÃ³n que aparece
primero en la gramÃ¡tica.</p>

<header>
<h4 align="center">Ejercicios</h4>
</header>

<font color=yellow><h4 align="center">Ejercicios LALR</h4></font>

Ejercicio 13.

Ejercicio 14.

<font color=yellow><h4 align="center">Proyectos</h4></font>

Proyecto 1.

Proyecto 2.

<header>
<h4 align="center">Generadores de analizadores sintÃ¡cticos
(YACC, JACC, JACCIE, GPPG)</h4>
</header>

<p>Yacc [9]. Es el que proporciona una herramienta general para describir la en-
trada para un programa de ordenador. El nombre yacc quiere decir â€œyet another
compiler-compilerâ€. El usuario del yacc especifica las estructuras de su input,
junto con el cÃ³digo que se va a llamar a medida que se reconocen cada estruc-
tura. Yacc convierte tal especificaciÃ³n en una subrutina que maneja el proceso
de input; frecuentemente, es conveniente y apropiado hacer que esta subrutina
maneje el flujo de control de la aplicaciÃ³n del usuario.
La subrutina producida por yacc llama a una rutina proporcionada por el
usuario para devolver el siguiente item de entrada bÃ¡sico. Por lo tanto, el usuario
puede especificar su entrada en tÃ©rminos de caracteres de entrada individuales o
en tÃ©rminos de construcciones de nivel mÃ¡s alto tales como nombres y nÃºmeros.
La rutina proporcionada por el usuario puede tambiÃ©n manejar caracterÄ±Ìsticas
idiomÃ¡ticas tales como convenciones de comentarios y de continuaciÃ³n, las cua-
les normalmente desafÄ±Ìan las especificaciones gramaticales sencillas. La clase de especificaciones aceptadas es una clase muy general: gramÃ¡ticas LALR con re-
glas que evitan la ambigÃ¼edad.
Una especificaciÃ³n en Yacc esta dividida en tres secciones separadas por el
sÄ±Ìmbolo % %:</p>

CÃ³digo.

<p>Las declaraciones del analizador incluye una lista de sÄ±Ìmbolos terminales y
no terminales.
Las reglas gramaticales son producciones de la forma;</p>

<font color=red><h4 align="center">exp : exp PLUS exp { acciÃ³n semÃ¡ntica }</h4></font>

<p>Donde exp es un no terminal que tiene como lado derecho exp + exp, y
PLUS es un sÄ±Ìmbolo terminal (token).
Los programas son cÃ³digo C usado como acciones semÃ¡nticas embebidas.</p>

<font color=yellow><h4 align="center">Ejemplo</h4></font>

<p>Se tiene la siguiente gramÃ¡tica:</p>

1. P â†’ L
2. S â†’ i := i
3. S â†’ while i do S
4. S â†’ begin L end
5. S â†’ if i then S
6. S â†’ if i then S else S
7. L â†’ S
8. L â†’ L ; S

<font color=yellow><h4 align="center">Programa en Yacc:</h4></font>

CÃ³digo.

<p>Jacc [8]. Es un generador de analizadores para Java [3] usa un modelado
cercano al yacc clÃ¡sico de Johnson [7]. Es fÃ¡cil de encontrar un generador de
analizador para Java incluyendo el CUP [4], Antlr [11], JavaCC [9], SableCC
[13], Coco/R [10], BYACC/Java [5], y el Jikes Parser Generator [12]. AsÄ±Ì que,
Â¿si queremos usar jacc en lugar de una de estas herramientas? En resumen, la
diferencia de jacc con otras herramientas, es la combinaciÃ³n de las siguientes
caracterÄ±Ìsticas:</p>

1. Compatibilidad sintÃ¡ctica con el generador de anlizador sintÃ¡ctico clÃ¡sico
de Johnson para C (de modo que es posible dar que dos herramientas
manejen diferentes lenguajes);
2. Compatibilidad semÃ¡ntica con el generador yaccâ€”jacc y el analizador
ascendente/desplazamiento-reducciÃ³n para gramÃ¡ticas LALR(1) con re-
glas de desambiguedad;
3. Una implementaciÃ³n pura con Java que es portable y reglas en Java para
desarrollar plataformas;
4. Agregados modestos para auxiliar a entender y depurar analizadores ge-
nerados, incluyendo: una caracterÄ±Ìstica para trazar el comportamiento de
una cadena de entrada, salida en HTML, y pruebas para conflictos LR(0)
y SLR(1);
5. Soporte primario para distribuir gramÃ¡ticas descritas a lo largo de mÃºlti-
ples archivos para soportar una construcciÃ³n modular o la extenciÃ³n del
analizador;
6. Un mecanismo para generar mensajes de error sintÃ¡ctico de ejemplos ba-
sados en ideas descritas por Jeffery [6];
7. Analizadores generados que usan la tÃ©cnica descrita por Bhamidipaty y
Proebsting [1] para crear fÃ¡cilmente el analizador yacc-compatible para
generar cÃ³digo en lugar de codificar un especÄ±Ìfico y particular anÃ¡lisis de
un conjunto de tablas como en la implementaciÃ³n del yacc clÃ¡sico.

</div>
</article>



<!--Ventana 1-->

<div id="openModal" class="modalDialog">
	<div>
		
		<h3><font color=black>FIGURA 1</font></h3>
		<a href="#close" title="Close" class="close">X</a>
		
		
			
	<font color=black>CaracterÃ­sticas de las figuras</font>.<table width="350" cellspacing="1" 				cellpadding="3" border="0" bgcolor="#80A93E" align="center">

			<tr>

   			<td bgcolor="#B7F259" align="center"><font size=4 face="verdana, arial, 			helvetica" color=black><b>Diagrama a bloques del programa objeto.</b></font></td> 
			</tr>

			<tr>

   			<td bgcolor="#F5ECB9"> 
			
			<p><img src="INTfig1.svg" width="500" height="450"></p>
    			
			</td></tr>
			</table>
 			

		
	</div>
</div>

<!--Ventana 2-->

<div id="openModal1" class="modalDialog">
	<div>
		<h3><font color=black>FIGURA 2</font></h3>
		
		<a href="#close" title="Close" class="close">X</a>
		
		
			
		<font color=black>CaracterÃ­sticas de las figuras</font>.<table width="350" 			cellspacing="1" cellpadding="3" border="0" bgcolor="#80A93E" align="center">

			<tr>

   			<td bgcolor="#B7F259" align="center"><font size=4 face="verdana, arial, 			helvetica" color=black><b>Diagrama a bloques de la arquitectura del intÃ©rprete.</b></font></td> 
			</tr>

			<tr>

   			<td bgcolor="#F5ECB9"> 
			
			<p><img src="INTfig2.svg" width="500" height="450"></p>
    			
			</td></tr>
			</table>
 			

		
	</div>
</div>

<!--Ventana 3-->

<div id="openModal2" class="modalDialog">
	<div>
		
		<h3><font color=black>FIGURA 3</font></h3>

		<a href="#close" title="Close" class="close">X</a>
		
		
			
		<font color=black>Lista de definiciones</font>.<table width="350" cellspacing="1" 				cellpadding="3" border="0" bgcolor="#80A93E" align="center">

			<tr>

   			<td bgcolor="#B7F259" align="center"><font size=4 face="verdana, arial, 			helvetica" color=black><b>DefiniciÃ³n de intÃ©rprete.</b></font></td> 
			</tr>

			<tr>

   			<td bgcolor="#F5ECB9"> 
			
		<p><font color=black>Otro tipo de traductor, llamado intÃ©rprete, procesa en forma 			interna el programa fuente y los datos al mismo tiempo. Es decir, la interpretaciÃ³n 				del formulario de origen interno se produce en tiempo de ejecuciÃ³n y no se 				genera ningÃºn programa objeto.</font></p>
    			
			</td></tr>
			</table>
 			

		
	</div>
</div>


<aside class="lateral">

<p class="p4">
<table class="t" CELLSPACING="18">
<tr><td><a href="#openModal">FIGURA 1</a></td><td><a href="#openModal1">FIGURA 2</a></td></tr>
<tr><td><a href="#openModal2">INTÃ‰RPRETE</a></td><td><a href="#openModal4">ConversiÃ³n</a></td></tr>
</table>
</p>

</aside>


</body>
</html>
